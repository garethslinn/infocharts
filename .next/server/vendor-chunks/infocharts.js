"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/infocharts";
exports.ids = ["vendor-chunks/infocharts"];
exports.modules = {

/***/ "(rsc)/./node_modules/infocharts/dist/styles/infocharts.css":
/*!************************************************************!*\
  !*** ./node_modules/infocharts/dist/styles/infocharts.css ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f015de97cb3c\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5mb2NoYXJ0cy9kaXN0L3N0eWxlcy9pbmZvY2hhcnRzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2luZm90ZXN0Ly4vbm9kZV9tb2R1bGVzL2luZm9jaGFydHMvZGlzdC9zdHlsZXMvaW5mb2NoYXJ0cy5jc3M/ZjM4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImYwMTVkZTk3Y2IzY1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/infocharts/dist/styles/infocharts.css\n");

/***/ }),

/***/ "(rsc)/./node_modules/infocharts/dist/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/infocharts/dist/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BenchmarkChart: () => (/* binding */ yn),\n/* harmony export */   ComparisonGraph: () => (/* binding */ sn),\n/* harmony export */   DoughnutChart: () => (/* binding */ an),\n/* harmony export */   DumbbellChart: () => (/* binding */ on),\n/* harmony export */   HeatMap: () => (/* binding */ pn),\n/* harmony export */   HorizontalBar: () => (/* binding */ ln),\n/* harmony export */   HorizontalList: () => (/* binding */ cn),\n/* harmony export */   RiskRating: () => (/* binding */ dn),\n/* harmony export */   SparkBar: () => (/* binding */ gn),\n/* harmony export */   SparkHorizontalBar: () => (/* binding */ bn),\n/* harmony export */   SparkLine: () => (/* binding */ xn),\n/* harmony export */   SparkStackedBar: () => (/* binding */ _n),\n/* harmony export */   SplineAreaChart: () => (/* binding */ fn),\n/* harmony export */   StackedAreaChart: () => (/* binding */ un),\n/* harmony export */   StackedBarChart: () => (/* binding */ hn),\n/* harmony export */   StackedRow: () => (/* binding */ vn),\n/* harmony export */   WaffleChart: () => (/* binding */ mn)\n/* harmony export */ });\nfunction qt(s) {\n  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nvar Ur = { exports: {} }, Xe = {}, br = { exports: {} }, A = {};\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar mt;\nfunction Kt() {\n  if (mt) return A;\n  mt = 1;\n  var s = Symbol.for(\"react.element\"), c = Symbol.for(\"react.portal\"), i = Symbol.for(\"react.fragment\"), f = Symbol.for(\"react.strict_mode\"), R = Symbol.for(\"react.profiler\"), j = Symbol.for(\"react.provider\"), b = Symbol.for(\"react.context\"), x = Symbol.for(\"react.forward_ref\"), h = Symbol.for(\"react.suspense\"), y = Symbol.for(\"react.memo\"), m = Symbol.for(\"react.lazy\"), E = Symbol.iterator;\n  function N(a) {\n    return a === null || typeof a != \"object\" ? null : (a = E && a[E] || a[\"@@iterator\"], typeof a == \"function\" ? a : null);\n  }\n  var L = { isMounted: function() {\n    return !1;\n  }, enqueueForceUpdate: function() {\n  }, enqueueReplaceState: function() {\n  }, enqueueSetState: function() {\n  } }, B = Object.assign, S = {};\n  function P(a, d, D) {\n    this.props = a, this.context = d, this.refs = S, this.updater = D || L;\n  }\n  P.prototype.isReactComponent = {}, P.prototype.setState = function(a, d) {\n    if (typeof a != \"object\" && typeof a != \"function\" && a != null) throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n    this.updater.enqueueSetState(this, a, d, \"setState\");\n  }, P.prototype.forceUpdate = function(a) {\n    this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n  };\n  function O() {\n  }\n  O.prototype = P.prototype;\n  function g(a, d, D) {\n    this.props = a, this.context = d, this.refs = S, this.updater = D || L;\n  }\n  var X = g.prototype = new O();\n  X.constructor = g, B(X, P.prototype), X.isPureReactComponent = !0;\n  var K = Array.isArray, J = Object.prototype.hasOwnProperty, ne = { current: null }, fe = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function ve(a, d, D) {\n    var I, W = {}, G = null, H = null;\n    if (d != null) for (I in d.ref !== void 0 && (H = d.ref), d.key !== void 0 && (G = \"\" + d.key), d) J.call(d, I) && !fe.hasOwnProperty(I) && (W[I] = d[I]);\n    var z = arguments.length - 2;\n    if (z === 1) W.children = D;\n    else if (1 < z) {\n      for (var Y = Array(z), ae = 0; ae < z; ae++) Y[ae] = arguments[ae + 2];\n      W.children = Y;\n    }\n    if (a && a.defaultProps) for (I in z = a.defaultProps, z) W[I] === void 0 && (W[I] = z[I]);\n    return { $$typeof: s, type: a, key: G, ref: H, props: W, _owner: ne.current };\n  }\n  function ge(a, d) {\n    return { $$typeof: s, type: a.type, key: d, ref: a.ref, props: a.props, _owner: a._owner };\n  }\n  function Ce(a) {\n    return typeof a == \"object\" && a !== null && a.$$typeof === s;\n  }\n  function Be(a) {\n    var d = { \"=\": \"=0\", \":\": \"=2\" };\n    return \"$\" + a.replace(/[=:]/g, function(D) {\n      return d[D];\n    });\n  }\n  var Se = /\\/+/g;\n  function ce(a, d) {\n    return typeof a == \"object\" && a !== null && a.key != null ? Be(\"\" + a.key) : d.toString(36);\n  }\n  function de(a, d, D, I, W) {\n    var G = typeof a;\n    (G === \"undefined\" || G === \"boolean\") && (a = null);\n    var H = !1;\n    if (a === null) H = !0;\n    else switch (G) {\n      case \"string\":\n      case \"number\":\n        H = !0;\n        break;\n      case \"object\":\n        switch (a.$$typeof) {\n          case s:\n          case c:\n            H = !0;\n        }\n    }\n    if (H) return H = a, W = W(H), a = I === \"\" ? \".\" + ce(H, 0) : I, K(W) ? (D = \"\", a != null && (D = a.replace(Se, \"$&/\") + \"/\"), de(W, d, D, \"\", function(ae) {\n      return ae;\n    })) : W != null && (Ce(W) && (W = ge(W, D + (!W.key || H && H.key === W.key ? \"\" : (\"\" + W.key).replace(Se, \"$&/\") + \"/\") + a)), d.push(W)), 1;\n    if (H = 0, I = I === \"\" ? \".\" : I + \":\", K(a)) for (var z = 0; z < a.length; z++) {\n      G = a[z];\n      var Y = I + ce(G, z);\n      H += de(G, d, D, Y, W);\n    }\n    else if (Y = N(a), typeof Y == \"function\") for (a = Y.call(a), z = 0; !(G = a.next()).done; ) G = G.value, Y = I + ce(G, z++), H += de(G, d, D, Y, W);\n    else if (G === \"object\") throw d = String(a), Error(\"Objects are not valid as a React child (found: \" + (d === \"[object Object]\" ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : d) + \"). If you meant to render a collection of children, use an array instead.\");\n    return H;\n  }\n  function se(a, d, D) {\n    if (a == null) return a;\n    var I = [], W = 0;\n    return de(a, I, \"\", \"\", function(G) {\n      return d.call(D, G, W++);\n    }), I;\n  }\n  function he(a) {\n    if (a._status === -1) {\n      var d = a._result;\n      d = d(), d.then(function(D) {\n        (a._status === 0 || a._status === -1) && (a._status = 1, a._result = D);\n      }, function(D) {\n        (a._status === 0 || a._status === -1) && (a._status = 2, a._result = D);\n      }), a._status === -1 && (a._status = 0, a._result = d);\n    }\n    if (a._status === 1) return a._result.default;\n    throw a._result;\n  }\n  var k = { current: null }, ye = { transition: null }, Oe = { ReactCurrentDispatcher: k, ReactCurrentBatchConfig: ye, ReactCurrentOwner: ne };\n  function be() {\n    throw Error(\"act(...) is not supported in production builds of React.\");\n  }\n  return A.Children = { map: se, forEach: function(a, d, D) {\n    se(a, function() {\n      d.apply(this, arguments);\n    }, D);\n  }, count: function(a) {\n    var d = 0;\n    return se(a, function() {\n      d++;\n    }), d;\n  }, toArray: function(a) {\n    return se(a, function(d) {\n      return d;\n    }) || [];\n  }, only: function(a) {\n    if (!Ce(a)) throw Error(\"React.Children.only expected to receive a single React element child.\");\n    return a;\n  } }, A.Component = P, A.Fragment = i, A.Profiler = R, A.PureComponent = g, A.StrictMode = f, A.Suspense = h, A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Oe, A.act = be, A.cloneElement = function(a, d, D) {\n    if (a == null) throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + a + \".\");\n    var I = B({}, a.props), W = a.key, G = a.ref, H = a._owner;\n    if (d != null) {\n      if (d.ref !== void 0 && (G = d.ref, H = ne.current), d.key !== void 0 && (W = \"\" + d.key), a.type && a.type.defaultProps) var z = a.type.defaultProps;\n      for (Y in d) J.call(d, Y) && !fe.hasOwnProperty(Y) && (I[Y] = d[Y] === void 0 && z !== void 0 ? z[Y] : d[Y]);\n    }\n    var Y = arguments.length - 2;\n    if (Y === 1) I.children = D;\n    else if (1 < Y) {\n      z = Array(Y);\n      for (var ae = 0; ae < Y; ae++) z[ae] = arguments[ae + 2];\n      I.children = z;\n    }\n    return { $$typeof: s, type: a.type, key: W, ref: G, props: I, _owner: H };\n  }, A.createContext = function(a) {\n    return a = { $$typeof: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a.Provider = { $$typeof: j, _context: a }, a.Consumer = a;\n  }, A.createElement = ve, A.createFactory = function(a) {\n    var d = ve.bind(null, a);\n    return d.type = a, d;\n  }, A.createRef = function() {\n    return { current: null };\n  }, A.forwardRef = function(a) {\n    return { $$typeof: x, render: a };\n  }, A.isValidElement = Ce, A.lazy = function(a) {\n    return { $$typeof: m, _payload: { _status: -1, _result: a }, _init: he };\n  }, A.memo = function(a, d) {\n    return { $$typeof: y, type: a, compare: d === void 0 ? null : d };\n  }, A.startTransition = function(a) {\n    var d = ye.transition;\n    ye.transition = {};\n    try {\n      a();\n    } finally {\n      ye.transition = d;\n    }\n  }, A.unstable_act = be, A.useCallback = function(a, d) {\n    return k.current.useCallback(a, d);\n  }, A.useContext = function(a) {\n    return k.current.useContext(a);\n  }, A.useDebugValue = function() {\n  }, A.useDeferredValue = function(a) {\n    return k.current.useDeferredValue(a);\n  }, A.useEffect = function(a, d) {\n    return k.current.useEffect(a, d);\n  }, A.useId = function() {\n    return k.current.useId();\n  }, A.useImperativeHandle = function(a, d, D) {\n    return k.current.useImperativeHandle(a, d, D);\n  }, A.useInsertionEffect = function(a, d) {\n    return k.current.useInsertionEffect(a, d);\n  }, A.useLayoutEffect = function(a, d) {\n    return k.current.useLayoutEffect(a, d);\n  }, A.useMemo = function(a, d) {\n    return k.current.useMemo(a, d);\n  }, A.useReducer = function(a, d, D) {\n    return k.current.useReducer(a, d, D);\n  }, A.useRef = function(a) {\n    return k.current.useRef(a);\n  }, A.useState = function(a) {\n    return k.current.useState(a);\n  }, A.useSyncExternalStore = function(a, d, D) {\n    return k.current.useSyncExternalStore(a, d, D);\n  }, A.useTransition = function() {\n    return k.current.useTransition();\n  }, A.version = \"18.3.1\", A;\n}\nvar Qe = { exports: {} };\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nQe.exports;\nvar gt;\nfunction Gt() {\n  return gt || (gt = 1, function(s, c) {\n     true && function() {\n      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n      var i = \"18.3.1\", f = Symbol.for(\"react.element\"), R = Symbol.for(\"react.portal\"), j = Symbol.for(\"react.fragment\"), b = Symbol.for(\"react.strict_mode\"), x = Symbol.for(\"react.profiler\"), h = Symbol.for(\"react.provider\"), y = Symbol.for(\"react.context\"), m = Symbol.for(\"react.forward_ref\"), E = Symbol.for(\"react.suspense\"), N = Symbol.for(\"react.suspense_list\"), L = Symbol.for(\"react.memo\"), B = Symbol.for(\"react.lazy\"), S = Symbol.for(\"react.offscreen\"), P = Symbol.iterator, O = \"@@iterator\";\n      function g(e) {\n        if (e === null || typeof e != \"object\")\n          return null;\n        var r = P && e[P] || e[O];\n        return typeof r == \"function\" ? r : null;\n      }\n      var X = {\n        /**\n         * @internal\n         * @type {ReactComponent}\n         */\n        current: null\n      }, K = {\n        transition: null\n      }, J = {\n        current: null,\n        // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n        isBatchingLegacy: !1,\n        didScheduleLegacyUpdate: !1\n      }, ne = {\n        /**\n         * @internal\n         * @type {ReactComponent}\n         */\n        current: null\n      }, fe = {}, ve = null;\n      function ge(e) {\n        ve = e;\n      }\n      fe.setExtraStackFrame = function(e) {\n        ve = e;\n      }, fe.getCurrentStack = null, fe.getStackAddendum = function() {\n        var e = \"\";\n        ve && (e += ve);\n        var r = fe.getCurrentStack;\n        return r && (e += r() || \"\"), e;\n      };\n      var Ce = !1, Be = !1, Se = !1, ce = !1, de = !1, se = {\n        ReactCurrentDispatcher: X,\n        ReactCurrentBatchConfig: K,\n        ReactCurrentOwner: ne\n      };\n      se.ReactDebugCurrentFrame = fe, se.ReactCurrentActQueue = J;\n      function he(e) {\n        {\n          for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), l = 1; l < r; l++)\n            o[l - 1] = arguments[l];\n          ye(\"warn\", e, o);\n        }\n      }\n      function k(e) {\n        {\n          for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), l = 1; l < r; l++)\n            o[l - 1] = arguments[l];\n          ye(\"error\", e, o);\n        }\n      }\n      function ye(e, r, o) {\n        {\n          var l = se.ReactDebugCurrentFrame, v = l.getStackAddendum();\n          v !== \"\" && (r += \"%s\", o = o.concat([v]));\n          var w = o.map(function(_) {\n            return String(_);\n          });\n          w.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, w);\n        }\n      }\n      var Oe = {};\n      function be(e, r) {\n        {\n          var o = e.constructor, l = o && (o.displayName || o.name) || \"ReactClass\", v = l + \".\" + r;\n          if (Oe[v])\n            return;\n          k(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", r, l), Oe[v] = !0;\n        }\n      }\n      var a = {\n        /**\n         * Checks whether or not this composite component is mounted.\n         * @param {ReactClass} publicInstance The instance we want to test.\n         * @return {boolean} True if mounted, false otherwise.\n         * @protected\n         * @final\n         */\n        isMounted: function(e) {\n          return !1;\n        },\n        /**\n         * Forces an update. This should only be invoked when it is known with\n         * certainty that we are **not** in a DOM transaction.\n         *\n         * You may want to call this when you know that some deeper aspect of the\n         * component's state has changed but `setState` was not called.\n         *\n         * This will not invoke `shouldComponentUpdate`, but it will invoke\n         * `componentWillUpdate` and `componentDidUpdate`.\n         *\n         * @param {ReactClass} publicInstance The instance that should rerender.\n         * @param {?function} callback Called after component is updated.\n         * @param {?string} callerName name of the calling function in the public API.\n         * @internal\n         */\n        enqueueForceUpdate: function(e, r, o) {\n          be(e, \"forceUpdate\");\n        },\n        /**\n         * Replaces all of the state. Always use this or `setState` to mutate state.\n         * You should treat `this.state` as immutable.\n         *\n         * There is no guarantee that `this.state` will be immediately updated, so\n         * accessing `this.state` after calling this method may return the old value.\n         *\n         * @param {ReactClass} publicInstance The instance that should rerender.\n         * @param {object} completeState Next state.\n         * @param {?function} callback Called after component is updated.\n         * @param {?string} callerName name of the calling function in the public API.\n         * @internal\n         */\n        enqueueReplaceState: function(e, r, o, l) {\n          be(e, \"replaceState\");\n        },\n        /**\n         * Sets a subset of the state. This only exists because _pendingState is\n         * internal. This provides a merging strategy that is not available to deep\n         * properties which is confusing. TODO: Expose pendingState or don't use it\n         * during the merge.\n         *\n         * @param {ReactClass} publicInstance The instance that should rerender.\n         * @param {object} partialState Next partial state to be merged with state.\n         * @param {?function} callback Called after component is updated.\n         * @param {?string} Name of the calling function in the public API.\n         * @internal\n         */\n        enqueueSetState: function(e, r, o, l) {\n          be(e, \"setState\");\n        }\n      }, d = Object.assign, D = {};\n      Object.freeze(D);\n      function I(e, r, o) {\n        this.props = e, this.context = r, this.refs = D, this.updater = o || a;\n      }\n      I.prototype.isReactComponent = {}, I.prototype.setState = function(e, r) {\n        if (typeof e != \"object\" && typeof e != \"function\" && e != null)\n          throw new Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n        this.updater.enqueueSetState(this, e, r, \"setState\");\n      }, I.prototype.forceUpdate = function(e) {\n        this.updater.enqueueForceUpdate(this, e, \"forceUpdate\");\n      };\n      {\n        var W = {\n          isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\n          replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\n        }, G = function(e, r) {\n          Object.defineProperty(I.prototype, e, {\n            get: function() {\n              he(\"%s(...) is deprecated in plain JavaScript React classes. %s\", r[0], r[1]);\n            }\n          });\n        };\n        for (var H in W)\n          W.hasOwnProperty(H) && G(H, W[H]);\n      }\n      function z() {\n      }\n      z.prototype = I.prototype;\n      function Y(e, r, o) {\n        this.props = e, this.context = r, this.refs = D, this.updater = o || a;\n      }\n      var ae = Y.prototype = new z();\n      ae.constructor = Y, d(ae, I.prototype), ae.isPureReactComponent = !0;\n      function xr() {\n        var e = {\n          current: null\n        };\n        return Object.seal(e), e;\n      }\n      var Ze = Array.isArray;\n      function Ie(e) {\n        return Ze(e);\n      }\n      function _r(e) {\n        {\n          var r = typeof Symbol == \"function\" && Symbol.toStringTag, o = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n          return o;\n        }\n      }\n      function Me(e) {\n        try {\n          return je(e), !1;\n        } catch {\n          return !0;\n        }\n      }\n      function je(e) {\n        return \"\" + e;\n      }\n      function Te(e) {\n        if (Me(e))\n          return k(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", _r(e)), je(e);\n      }\n      function er(e, r, o) {\n        var l = e.displayName;\n        if (l)\n          return l;\n        var v = r.displayName || r.name || \"\";\n        return v !== \"\" ? o + \"(\" + v + \")\" : o;\n      }\n      function Pe(e) {\n        return e.displayName || \"Context\";\n      }\n      function me(e) {\n        if (e == null)\n          return null;\n        if (typeof e.tag == \"number\" && k(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n          return e.displayName || e.name || null;\n        if (typeof e == \"string\")\n          return e;\n        switch (e) {\n          case j:\n            return \"Fragment\";\n          case R:\n            return \"Portal\";\n          case x:\n            return \"Profiler\";\n          case b:\n            return \"StrictMode\";\n          case E:\n            return \"Suspense\";\n          case N:\n            return \"SuspenseList\";\n        }\n        if (typeof e == \"object\")\n          switch (e.$$typeof) {\n            case y:\n              var r = e;\n              return Pe(r) + \".Consumer\";\n            case h:\n              var o = e;\n              return Pe(o._context) + \".Provider\";\n            case m:\n              return er(e, e.render, \"ForwardRef\");\n            case L:\n              var l = e.displayName || null;\n              return l !== null ? l : me(e.type) || \"Memo\";\n            case B: {\n              var v = e, w = v._payload, _ = v._init;\n              try {\n                return me(_(w));\n              } catch {\n                return null;\n              }\n            }\n          }\n        return null;\n      }\n      var Ne = Object.prototype.hasOwnProperty, Le = {\n        key: !0,\n        ref: !0,\n        __self: !0,\n        __source: !0\n      }, rr, tr, We;\n      We = {};\n      function ze(e) {\n        if (Ne.call(e, \"ref\")) {\n          var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n          if (r && r.isReactWarning)\n            return !1;\n        }\n        return e.ref !== void 0;\n      }\n      function Re(e) {\n        if (Ne.call(e, \"key\")) {\n          var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n          if (r && r.isReactWarning)\n            return !1;\n        }\n        return e.key !== void 0;\n      }\n      function jr(e, r) {\n        var o = function() {\n          rr || (rr = !0, k(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        o.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: o,\n          configurable: !0\n        });\n      }\n      function nr(e, r) {\n        var o = function() {\n          tr || (tr = !0, k(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        o.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: o,\n          configurable: !0\n        });\n      }\n      function ar(e) {\n        if (typeof e.ref == \"string\" && ne.current && e.__self && ne.current.stateNode !== e.__self) {\n          var r = me(ne.current.type);\n          We[r] || (k('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', r, e.ref), We[r] = !0);\n        }\n      }\n      var $e = function(e, r, o, l, v, w, _) {\n        var T = {\n          // This tag allows us to uniquely identify this as a React Element\n          $$typeof: f,\n          // Built-in properties that belong on the element\n          type: e,\n          key: r,\n          ref: o,\n          props: _,\n          // Record the component responsible for creating this element.\n          _owner: w\n        };\n        return T._store = {}, Object.defineProperty(T._store, \"validated\", {\n          configurable: !1,\n          enumerable: !1,\n          writable: !0,\n          value: !1\n        }), Object.defineProperty(T, \"_self\", {\n          configurable: !1,\n          enumerable: !1,\n          writable: !1,\n          value: l\n        }), Object.defineProperty(T, \"_source\", {\n          configurable: !1,\n          enumerable: !1,\n          writable: !1,\n          value: v\n        }), Object.freeze && (Object.freeze(T.props), Object.freeze(T)), T;\n      };\n      function Rr(e, r, o) {\n        var l, v = {}, w = null, _ = null, T = null, M = null;\n        if (r != null) {\n          ze(r) && (_ = r.ref, ar(r)), Re(r) && (Te(r.key), w = \"\" + r.key), T = r.__self === void 0 ? null : r.__self, M = r.__source === void 0 ? null : r.__source;\n          for (l in r)\n            Ne.call(r, l) && !Le.hasOwnProperty(l) && (v[l] = r[l]);\n        }\n        var q = arguments.length - 2;\n        if (q === 1)\n          v.children = o;\n        else if (q > 1) {\n          for (var Q = Array(q), Z = 0; Z < q; Z++)\n            Q[Z] = arguments[Z + 2];\n          Object.freeze && Object.freeze(Q), v.children = Q;\n        }\n        if (e && e.defaultProps) {\n          var re = e.defaultProps;\n          for (l in re)\n            v[l] === void 0 && (v[l] = re[l]);\n        }\n        if (w || _) {\n          var oe = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          w && jr(v, oe), _ && nr(v, oe);\n        }\n        return $e(e, w, _, T, M, ne.current, v);\n      }\n      function Er(e, r) {\n        var o = $e(e.type, r, e.ref, e._self, e._source, e._owner, e.props);\n        return o;\n      }\n      function kr(e, r, o) {\n        if (e == null)\n          throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + e + \".\");\n        var l, v = d({}, e.props), w = e.key, _ = e.ref, T = e._self, M = e._source, q = e._owner;\n        if (r != null) {\n          ze(r) && (_ = r.ref, q = ne.current), Re(r) && (Te(r.key), w = \"\" + r.key);\n          var Q;\n          e.type && e.type.defaultProps && (Q = e.type.defaultProps);\n          for (l in r)\n            Ne.call(r, l) && !Le.hasOwnProperty(l) && (r[l] === void 0 && Q !== void 0 ? v[l] = Q[l] : v[l] = r[l]);\n        }\n        var Z = arguments.length - 2;\n        if (Z === 1)\n          v.children = o;\n        else if (Z > 1) {\n          for (var re = Array(Z), oe = 0; oe < Z; oe++)\n            re[oe] = arguments[oe + 2];\n          v.children = re;\n        }\n        return $e(e.type, w, _, T, M, q, v);\n      }\n      function Ee(e) {\n        return typeof e == \"object\" && e !== null && e.$$typeof === f;\n      }\n      var or = \".\", wr = \":\";\n      function Cr(e) {\n        var r = /[=:]/g, o = {\n          \"=\": \"=0\",\n          \":\": \"=2\"\n        }, l = e.replace(r, function(v) {\n          return o[v];\n        });\n        return \"$\" + l;\n      }\n      var Ve = !1, sr = /\\/+/g;\n      function xe(e) {\n        return e.replace(sr, \"$&/\");\n      }\n      function Ae(e, r) {\n        return typeof e == \"object\" && e !== null && e.key != null ? (Te(e.key), Cr(\"\" + e.key)) : r.toString(36);\n      }\n      function ke(e, r, o, l, v) {\n        var w = typeof e;\n        (w === \"undefined\" || w === \"boolean\") && (e = null);\n        var _ = !1;\n        if (e === null)\n          _ = !0;\n        else\n          switch (w) {\n            case \"string\":\n            case \"number\":\n              _ = !0;\n              break;\n            case \"object\":\n              switch (e.$$typeof) {\n                case f:\n                case R:\n                  _ = !0;\n              }\n          }\n        if (_) {\n          var T = e, M = v(T), q = l === \"\" ? or + Ae(T, 0) : l;\n          if (Ie(M)) {\n            var Q = \"\";\n            q != null && (Q = xe(q) + \"/\"), ke(M, r, Q, \"\", function(Ht) {\n              return Ht;\n            });\n          } else M != null && (Ee(M) && (M.key && (!T || T.key !== M.key) && Te(M.key), M = Er(\n            M,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            o + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            (M.key && (!T || T.key !== M.key) ? (\n              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n              // eslint-disable-next-line react-internal/safe-string-coercion\n              xe(\"\" + M.key) + \"/\"\n            ) : \"\") + q\n          )), r.push(M));\n          return 1;\n        }\n        var Z, re, oe = 0, le = l === \"\" ? or : l + wr;\n        if (Ie(e))\n          for (var gr = 0; gr < e.length; gr++)\n            Z = e[gr], re = le + Ae(Z, gr), oe += ke(Z, r, o, re, v);\n        else {\n          var Yr = g(e);\n          if (typeof Yr == \"function\") {\n            var vt = e;\n            Yr === vt.entries && (Ve || he(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), Ve = !0);\n            for (var Bt = Yr.call(vt), ht, zt = 0; !(ht = Bt.next()).done; )\n              Z = ht.value, re = le + Ae(Z, zt++), oe += ke(Z, r, o, re, v);\n          } else if (w === \"object\") {\n            var yt = String(e);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (yt === \"[object Object]\" ? \"object with keys {\" + Object.keys(e).join(\", \") + \"}\" : yt) + \"). If you meant to render a collection of children, use an array instead.\");\n          }\n        }\n        return oe;\n      }\n      function De(e, r, o) {\n        if (e == null)\n          return e;\n        var l = [], v = 0;\n        return ke(e, l, \"\", \"\", function(w) {\n          return r.call(o, w, v++);\n        }), l;\n      }\n      function Sr(e) {\n        var r = 0;\n        return De(e, function() {\n          r++;\n        }), r;\n      }\n      function ir(e, r, o) {\n        De(e, function() {\n          r.apply(this, arguments);\n        }, o);\n      }\n      function Or(e) {\n        return De(e, function(r) {\n          return r;\n        }) || [];\n      }\n      function lr(e) {\n        if (!Ee(e))\n          throw new Error(\"React.Children.only expected to receive a single React element child.\");\n        return e;\n      }\n      function cr(e) {\n        var r = {\n          $$typeof: y,\n          // As a workaround to support multiple concurrent renderers, we categorize\n          // some renderers as primary and others as secondary. We only expect\n          // there to be two concurrent renderers at most: React Native (primary) and\n          // Fabric (secondary); React DOM (primary) and React ART (secondary).\n          // Secondary renderers store their context values on separate fields.\n          _currentValue: e,\n          _currentValue2: e,\n          // Used to track how many concurrent renderers this context currently\n          // supports within in a single renderer. Such as parallel server rendering.\n          _threadCount: 0,\n          // These are circular\n          Provider: null,\n          Consumer: null,\n          // Add these to use same hidden class in VM as ServerContext\n          _defaultValue: null,\n          _globalName: null\n        };\n        r.Provider = {\n          $$typeof: h,\n          _context: r\n        };\n        var o = !1, l = !1, v = !1;\n        {\n          var w = {\n            $$typeof: y,\n            _context: r\n          };\n          Object.defineProperties(w, {\n            Provider: {\n              get: function() {\n                return l || (l = !0, k(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?\")), r.Provider;\n              },\n              set: function(_) {\n                r.Provider = _;\n              }\n            },\n            _currentValue: {\n              get: function() {\n                return r._currentValue;\n              },\n              set: function(_) {\n                r._currentValue = _;\n              }\n            },\n            _currentValue2: {\n              get: function() {\n                return r._currentValue2;\n              },\n              set: function(_) {\n                r._currentValue2 = _;\n              }\n            },\n            _threadCount: {\n              get: function() {\n                return r._threadCount;\n              },\n              set: function(_) {\n                r._threadCount = _;\n              }\n            },\n            Consumer: {\n              get: function() {\n                return o || (o = !0, k(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\")), r.Consumer;\n              }\n            },\n            displayName: {\n              get: function() {\n                return r.displayName;\n              },\n              set: function(_) {\n                v || (he(\"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.\", _), v = !0);\n              }\n            }\n          }), r.Consumer = w;\n        }\n        return r._currentRenderer = null, r._currentRenderer2 = null, r;\n      }\n      var Fe = -1, He = 0, qe = 1, ur = 2;\n      function Tr(e) {\n        if (e._status === Fe) {\n          var r = e._result, o = r();\n          if (o.then(function(w) {\n            if (e._status === He || e._status === Fe) {\n              var _ = e;\n              _._status = qe, _._result = w;\n            }\n          }, function(w) {\n            if (e._status === He || e._status === Fe) {\n              var _ = e;\n              _._status = ur, _._result = w;\n            }\n          }), e._status === Fe) {\n            var l = e;\n            l._status = He, l._result = o;\n          }\n        }\n        if (e._status === qe) {\n          var v = e._result;\n          return v === void 0 && k(`lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?`, v), \"default\" in v || k(`lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))`, v), v.default;\n        } else\n          throw e._result;\n      }\n      function Pr(e) {\n        var r = {\n          // We use these fields to store the result.\n          _status: Fe,\n          _result: e\n        }, o = {\n          $$typeof: B,\n          _payload: r,\n          _init: Tr\n        };\n        {\n          var l, v;\n          Object.defineProperties(o, {\n            defaultProps: {\n              configurable: !0,\n              get: function() {\n                return l;\n              },\n              set: function(w) {\n                k(\"React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\"), l = w, Object.defineProperty(o, \"defaultProps\", {\n                  enumerable: !0\n                });\n              }\n            },\n            propTypes: {\n              configurable: !0,\n              get: function() {\n                return v;\n              },\n              set: function(w) {\n                k(\"React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\"), v = w, Object.defineProperty(o, \"propTypes\", {\n                  enumerable: !0\n                });\n              }\n            }\n          });\n        }\n        return o;\n      }\n      function Nr(e) {\n        e != null && e.$$typeof === L ? k(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\") : typeof e != \"function\" ? k(\"forwardRef requires a render function but was given %s.\", e === null ? \"null\" : typeof e) : e.length !== 0 && e.length !== 2 && k(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", e.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\"), e != null && (e.defaultProps != null || e.propTypes != null) && k(\"forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?\");\n        var r = {\n          $$typeof: m,\n          render: e\n        };\n        {\n          var o;\n          Object.defineProperty(r, \"displayName\", {\n            enumerable: !1,\n            configurable: !0,\n            get: function() {\n              return o;\n            },\n            set: function(l) {\n              o = l, !e.name && !e.displayName && (e.displayName = l);\n            }\n          });\n        }\n        return r;\n      }\n      var fr;\n      fr = Symbol.for(\"react.module.reference\");\n      function t(e) {\n        return !!(typeof e == \"string\" || typeof e == \"function\" || e === j || e === x || de || e === b || e === E || e === N || ce || e === S || Ce || Be || Se || typeof e == \"object\" && e !== null && (e.$$typeof === B || e.$$typeof === L || e.$$typeof === h || e.$$typeof === y || e.$$typeof === m || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        e.$$typeof === fr || e.getModuleId !== void 0));\n      }\n      function u(e, r) {\n        t(e) || k(\"memo: The first argument must be a component. Instead received: %s\", e === null ? \"null\" : typeof e);\n        var o = {\n          $$typeof: L,\n          type: e,\n          compare: r === void 0 ? null : r\n        };\n        {\n          var l;\n          Object.defineProperty(o, \"displayName\", {\n            enumerable: !1,\n            configurable: !0,\n            get: function() {\n              return l;\n            },\n            set: function(v) {\n              l = v, !e.name && !e.displayName && (e.displayName = v);\n            }\n          });\n        }\n        return o;\n      }\n      function p() {\n        var e = X.current;\n        return e === null && k(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), e;\n      }\n      function C(e) {\n        var r = p();\n        if (e._context !== void 0) {\n          var o = e._context;\n          o.Consumer === e ? k(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?\") : o.Provider === e && k(\"Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?\");\n        }\n        return r.useContext(e);\n      }\n      function V(e) {\n        var r = p();\n        return r.useState(e);\n      }\n      function U(e, r, o) {\n        var l = p();\n        return l.useReducer(e, r, o);\n      }\n      function F(e) {\n        var r = p();\n        return r.useRef(e);\n      }\n      function $(e, r) {\n        var o = p();\n        return o.useEffect(e, r);\n      }\n      function ie(e, r) {\n        var o = p();\n        return o.useInsertionEffect(e, r);\n      }\n      function ee(e, r) {\n        var o = p();\n        return o.useLayoutEffect(e, r);\n      }\n      function te(e, r) {\n        var o = p();\n        return o.useCallback(e, r);\n      }\n      function pe(e, r) {\n        var o = p();\n        return o.useMemo(e, r);\n      }\n      function we(e, r, o) {\n        var l = p();\n        return l.useImperativeHandle(e, r, o);\n      }\n      function _e(e, r) {\n        {\n          var o = p();\n          return o.useDebugValue(e, r);\n        }\n      }\n      function ue() {\n        var e = p();\n        return e.useTransition();\n      }\n      function Ke(e) {\n        var r = p();\n        return r.useDeferredValue(e);\n      }\n      function $r() {\n        var e = p();\n        return e.useId();\n      }\n      function Ar(e, r, o) {\n        var l = p();\n        return l.useSyncExternalStore(e, r, o);\n      }\n      var Ge = 0, qr, Kr, Gr, Xr, Jr, Qr, Zr;\n      function et() {\n      }\n      et.__reactDisabledLog = !0;\n      function wt() {\n        {\n          if (Ge === 0) {\n            qr = console.log, Kr = console.info, Gr = console.warn, Xr = console.error, Jr = console.group, Qr = console.groupCollapsed, Zr = console.groupEnd;\n            var e = {\n              configurable: !0,\n              enumerable: !0,\n              value: et,\n              writable: !0\n            };\n            Object.defineProperties(console, {\n              info: e,\n              log: e,\n              warn: e,\n              error: e,\n              group: e,\n              groupCollapsed: e,\n              groupEnd: e\n            });\n          }\n          Ge++;\n        }\n      }\n      function Ct() {\n        {\n          if (Ge--, Ge === 0) {\n            var e = {\n              configurable: !0,\n              enumerable: !0,\n              writable: !0\n            };\n            Object.defineProperties(console, {\n              log: d({}, e, {\n                value: qr\n              }),\n              info: d({}, e, {\n                value: Kr\n              }),\n              warn: d({}, e, {\n                value: Gr\n              }),\n              error: d({}, e, {\n                value: Xr\n              }),\n              group: d({}, e, {\n                value: Jr\n              }),\n              groupCollapsed: d({}, e, {\n                value: Qr\n              }),\n              groupEnd: d({}, e, {\n                value: Zr\n              })\n            });\n          }\n          Ge < 0 && k(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n        }\n      }\n      var Dr = se.ReactCurrentDispatcher, Fr;\n      function dr(e, r, o) {\n        {\n          if (Fr === void 0)\n            try {\n              throw Error();\n            } catch (v) {\n              var l = v.stack.trim().match(/\\n( *(at )?)/);\n              Fr = l && l[1] || \"\";\n            }\n          return `\n` + Fr + e;\n        }\n      }\n      var Ir = !1, pr;\n      {\n        var St = typeof WeakMap == \"function\" ? WeakMap : Map;\n        pr = new St();\n      }\n      function rt(e, r) {\n        if (!e || Ir)\n          return \"\";\n        {\n          var o = pr.get(e);\n          if (o !== void 0)\n            return o;\n        }\n        var l;\n        Ir = !0;\n        var v = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var w;\n        w = Dr.current, Dr.current = null, wt();\n        try {\n          if (r) {\n            var _ = function() {\n              throw Error();\n            };\n            if (Object.defineProperty(_.prototype, \"props\", {\n              set: function() {\n                throw Error();\n              }\n            }), typeof Reflect == \"object\" && Reflect.construct) {\n              try {\n                Reflect.construct(_, []);\n              } catch (le) {\n                l = le;\n              }\n              Reflect.construct(e, [], _);\n            } else {\n              try {\n                _.call();\n              } catch (le) {\n                l = le;\n              }\n              e.call(_.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (le) {\n              l = le;\n            }\n            e();\n          }\n        } catch (le) {\n          if (le && l && typeof le.stack == \"string\") {\n            for (var T = le.stack.split(`\n`), M = l.stack.split(`\n`), q = T.length - 1, Q = M.length - 1; q >= 1 && Q >= 0 && T[q] !== M[Q]; )\n              Q--;\n            for (; q >= 1 && Q >= 0; q--, Q--)\n              if (T[q] !== M[Q]) {\n                if (q !== 1 || Q !== 1)\n                  do\n                    if (q--, Q--, Q < 0 || T[q] !== M[Q]) {\n                      var Z = `\n` + T[q].replace(\" at new \", \" at \");\n                      return e.displayName && Z.includes(\"<anonymous>\") && (Z = Z.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && pr.set(e, Z), Z;\n                    }\n                  while (q >= 1 && Q >= 0);\n                break;\n              }\n          }\n        } finally {\n          Ir = !1, Dr.current = w, Ct(), Error.prepareStackTrace = v;\n        }\n        var re = e ? e.displayName || e.name : \"\", oe = re ? dr(re) : \"\";\n        return typeof e == \"function\" && pr.set(e, oe), oe;\n      }\n      function Ot(e, r, o) {\n        return rt(e, !1);\n      }\n      function Tt(e) {\n        var r = e.prototype;\n        return !!(r && r.isReactComponent);\n      }\n      function vr(e, r, o) {\n        if (e == null)\n          return \"\";\n        if (typeof e == \"function\")\n          return rt(e, Tt(e));\n        if (typeof e == \"string\")\n          return dr(e);\n        switch (e) {\n          case E:\n            return dr(\"Suspense\");\n          case N:\n            return dr(\"SuspenseList\");\n        }\n        if (typeof e == \"object\")\n          switch (e.$$typeof) {\n            case m:\n              return Ot(e.render);\n            case L:\n              return vr(e.type, r, o);\n            case B: {\n              var l = e, v = l._payload, w = l._init;\n              try {\n                return vr(w(v), r, o);\n              } catch {\n              }\n            }\n          }\n        return \"\";\n      }\n      var tt = {}, nt = se.ReactDebugCurrentFrame;\n      function hr(e) {\n        if (e) {\n          var r = e._owner, o = vr(e.type, e._source, r ? r.type : null);\n          nt.setExtraStackFrame(o);\n        } else\n          nt.setExtraStackFrame(null);\n      }\n      function Pt(e, r, o, l, v) {\n        {\n          var w = Function.call.bind(Ne);\n          for (var _ in e)\n            if (w(e, _)) {\n              var T = void 0;\n              try {\n                if (typeof e[_] != \"function\") {\n                  var M = Error((l || \"React class\") + \": \" + o + \" type `\" + _ + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[_] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                  throw M.name = \"Invariant Violation\", M;\n                }\n                T = e[_](r, _, l, o, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n              } catch (q) {\n                T = q;\n              }\n              T && !(T instanceof Error) && (hr(v), k(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", l || \"React class\", o, _, typeof T), hr(null)), T instanceof Error && !(T.message in tt) && (tt[T.message] = !0, hr(v), k(\"Failed %s type: %s\", o, T.message), hr(null));\n            }\n        }\n      }\n      function Ye(e) {\n        if (e) {\n          var r = e._owner, o = vr(e.type, e._source, r ? r.type : null);\n          ge(o);\n        } else\n          ge(null);\n      }\n      var Mr;\n      Mr = !1;\n      function at() {\n        if (ne.current) {\n          var e = me(ne.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n      function Nt(e) {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), o = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + o + \".\";\n        }\n        return \"\";\n      }\n      function $t(e) {\n        return e != null ? Nt(e.__source) : \"\";\n      }\n      var ot = {};\n      function At(e) {\n        var r = at();\n        if (!r) {\n          var o = typeof e == \"string\" ? e : e.displayName || e.name;\n          o && (r = `\n\nCheck the top-level render call using <` + o + \">.\");\n        }\n        return r;\n      }\n      function st(e, r) {\n        if (!(!e._store || e._store.validated || e.key != null)) {\n          e._store.validated = !0;\n          var o = At(r);\n          if (!ot[o]) {\n            ot[o] = !0;\n            var l = \"\";\n            e && e._owner && e._owner !== ne.current && (l = \" It was passed a child from \" + me(e._owner.type) + \".\"), Ye(e), k('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', o, l), Ye(null);\n          }\n        }\n      }\n      function it(e, r) {\n        if (typeof e == \"object\") {\n          if (Ie(e))\n            for (var o = 0; o < e.length; o++) {\n              var l = e[o];\n              Ee(l) && st(l, r);\n            }\n          else if (Ee(e))\n            e._store && (e._store.validated = !0);\n          else if (e) {\n            var v = g(e);\n            if (typeof v == \"function\" && v !== e.entries)\n              for (var w = v.call(e), _; !(_ = w.next()).done; )\n                Ee(_.value) && st(_.value, r);\n          }\n        }\n      }\n      function lt(e) {\n        {\n          var r = e.type;\n          if (r == null || typeof r == \"string\")\n            return;\n          var o;\n          if (typeof r == \"function\")\n            o = r.propTypes;\n          else if (typeof r == \"object\" && (r.$$typeof === m || // Note: Memo only checks outer props here.\n          // Inner props are checked in the reconciler.\n          r.$$typeof === L))\n            o = r.propTypes;\n          else\n            return;\n          if (o) {\n            var l = me(r);\n            Pt(o, e.props, \"prop\", l, e);\n          } else if (r.PropTypes !== void 0 && !Mr) {\n            Mr = !0;\n            var v = me(r);\n            k(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", v || \"Unknown\");\n          }\n          typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && k(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n        }\n      }\n      function Dt(e) {\n        {\n          for (var r = Object.keys(e.props), o = 0; o < r.length; o++) {\n            var l = r[o];\n            if (l !== \"children\" && l !== \"key\") {\n              Ye(e), k(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", l), Ye(null);\n              break;\n            }\n          }\n          e.ref !== null && (Ye(e), k(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), Ye(null));\n        }\n      }\n      function ct(e, r, o) {\n        var l = t(e);\n        if (!l) {\n          var v = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (v += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var w = $t(r);\n          w ? v += w : v += at();\n          var _;\n          e === null ? _ = \"null\" : Ie(e) ? _ = \"array\" : e !== void 0 && e.$$typeof === f ? (_ = \"<\" + (me(e.type) || \"Unknown\") + \" />\", v = \" Did you accidentally export a JSX literal instead of a component?\") : _ = typeof e, k(\"React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", _, v);\n        }\n        var T = Rr.apply(this, arguments);\n        if (T == null)\n          return T;\n        if (l)\n          for (var M = 2; M < arguments.length; M++)\n            it(arguments[M], e);\n        return e === j ? Dt(T) : lt(T), T;\n      }\n      var ut = !1;\n      function Ft(e) {\n        var r = ct.bind(null, e);\n        return r.type = e, ut || (ut = !0, he(\"React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\")), Object.defineProperty(r, \"type\", {\n          enumerable: !1,\n          get: function() {\n            return he(\"Factory.type is deprecated. Access the class directly before passing it to createFactory.\"), Object.defineProperty(this, \"type\", {\n              value: e\n            }), e;\n          }\n        }), r;\n      }\n      function It(e, r, o) {\n        for (var l = kr.apply(this, arguments), v = 2; v < arguments.length; v++)\n          it(arguments[v], l.type);\n        return lt(l), l;\n      }\n      function Mt(e, r) {\n        var o = K.transition;\n        K.transition = {};\n        var l = K.transition;\n        K.transition._updatedFibers = /* @__PURE__ */ new Set();\n        try {\n          e();\n        } finally {\n          if (K.transition = o, o === null && l._updatedFibers) {\n            var v = l._updatedFibers.size;\n            v > 10 && he(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"), l._updatedFibers.clear();\n          }\n        }\n      }\n      var ft = !1, yr = null;\n      function Lt(e) {\n        if (yr === null)\n          try {\n            var r = (\"require\" + Math.random()).slice(0, 7), o = s && s[r];\n            yr = o.call(s, \"timers\").setImmediate;\n          } catch {\n            yr = function(v) {\n              ft === !1 && (ft = !0, typeof MessageChannel > \"u\" && k(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"));\n              var w = new MessageChannel();\n              w.port1.onmessage = v, w.port2.postMessage(void 0);\n            };\n          }\n        return yr(e);\n      }\n      var Ue = 0, dt = !1;\n      function pt(e) {\n        {\n          var r = Ue;\n          Ue++, J.current === null && (J.current = []);\n          var o = J.isBatchingLegacy, l;\n          try {\n            if (J.isBatchingLegacy = !0, l = e(), !o && J.didScheduleLegacyUpdate) {\n              var v = J.current;\n              v !== null && (J.didScheduleLegacyUpdate = !1, Vr(v));\n            }\n          } catch (re) {\n            throw mr(r), re;\n          } finally {\n            J.isBatchingLegacy = o;\n          }\n          if (l !== null && typeof l == \"object\" && typeof l.then == \"function\") {\n            var w = l, _ = !1, T = {\n              then: function(re, oe) {\n                _ = !0, w.then(function(le) {\n                  mr(r), Ue === 0 ? Lr(le, re, oe) : re(le);\n                }, function(le) {\n                  mr(r), oe(le);\n                });\n              }\n            };\n            return !dt && typeof Promise < \"u\" && Promise.resolve().then(function() {\n            }).then(function() {\n              _ || (dt = !0, k(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"));\n            }), T;\n          } else {\n            var M = l;\n            if (mr(r), Ue === 0) {\n              var q = J.current;\n              q !== null && (Vr(q), J.current = null);\n              var Q = {\n                then: function(re, oe) {\n                  J.current === null ? (J.current = [], Lr(M, re, oe)) : re(M);\n                }\n              };\n              return Q;\n            } else {\n              var Z = {\n                then: function(re, oe) {\n                  re(M);\n                }\n              };\n              return Z;\n            }\n          }\n        }\n      }\n      function mr(e) {\n        e !== Ue - 1 && k(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \"), Ue = e;\n      }\n      function Lr(e, r, o) {\n        {\n          var l = J.current;\n          if (l !== null)\n            try {\n              Vr(l), Lt(function() {\n                l.length === 0 ? (J.current = null, r(e)) : Lr(e, r, o);\n              });\n            } catch (v) {\n              o(v);\n            }\n          else\n            r(e);\n        }\n      }\n      var Wr = !1;\n      function Vr(e) {\n        if (!Wr) {\n          Wr = !0;\n          var r = 0;\n          try {\n            for (; r < e.length; r++) {\n              var o = e[r];\n              do\n                o = o(!0);\n              while (o !== null);\n            }\n            e.length = 0;\n          } catch (l) {\n            throw e = e.slice(r + 1), l;\n          } finally {\n            Wr = !1;\n          }\n        }\n      }\n      var Wt = ct, Vt = It, Yt = Ft, Ut = {\n        map: De,\n        forEach: ir,\n        count: Sr,\n        toArray: Or,\n        only: lr\n      };\n      c.Children = Ut, c.Component = I, c.Fragment = j, c.Profiler = x, c.PureComponent = Y, c.StrictMode = b, c.Suspense = E, c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se, c.act = pt, c.cloneElement = Vt, c.createContext = cr, c.createElement = Wt, c.createFactory = Yt, c.createRef = xr, c.forwardRef = Nr, c.isValidElement = Ee, c.lazy = Pr, c.memo = u, c.startTransition = Mt, c.unstable_act = pt, c.useCallback = te, c.useContext = C, c.useDebugValue = _e, c.useDeferredValue = Ke, c.useEffect = $, c.useId = $r, c.useImperativeHandle = we, c.useInsertionEffect = ie, c.useLayoutEffect = ee, c.useMemo = pe, c.useReducer = U, c.useRef = F, c.useState = V, c.useSyncExternalStore = Ar, c.useTransition = ue, c.version = i, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }();\n  }(Qe, Qe.exports)), Qe.exports;\n}\nvar bt;\nfunction Hr() {\n  return bt || (bt = 1,  false ? 0 : br.exports = Gt()), br.exports;\n}\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar xt;\nfunction Xt() {\n  if (xt) return Xe;\n  xt = 1;\n  var s = Hr(), c = Symbol.for(\"react.element\"), i = Symbol.for(\"react.fragment\"), f = Object.prototype.hasOwnProperty, R = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, j = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function b(x, h, y) {\n    var m, E = {}, N = null, L = null;\n    y !== void 0 && (N = \"\" + y), h.key !== void 0 && (N = \"\" + h.key), h.ref !== void 0 && (L = h.ref);\n    for (m in h) f.call(h, m) && !j.hasOwnProperty(m) && (E[m] = h[m]);\n    if (x && x.defaultProps) for (m in h = x.defaultProps, h) E[m] === void 0 && (E[m] = h[m]);\n    return { $$typeof: c, type: x, key: N, ref: L, props: E, _owner: R.current };\n  }\n  return Xe.Fragment = i, Xe.jsx = b, Xe.jsxs = b, Xe;\n}\nvar Je = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar _t;\nfunction Jt() {\n  return _t || (_t = 1,  true && function() {\n    var s = Hr(), c = Symbol.for(\"react.element\"), i = Symbol.for(\"react.portal\"), f = Symbol.for(\"react.fragment\"), R = Symbol.for(\"react.strict_mode\"), j = Symbol.for(\"react.profiler\"), b = Symbol.for(\"react.provider\"), x = Symbol.for(\"react.context\"), h = Symbol.for(\"react.forward_ref\"), y = Symbol.for(\"react.suspense\"), m = Symbol.for(\"react.suspense_list\"), E = Symbol.for(\"react.memo\"), N = Symbol.for(\"react.lazy\"), L = Symbol.for(\"react.offscreen\"), B = Symbol.iterator, S = \"@@iterator\";\n    function P(t) {\n      if (t === null || typeof t != \"object\")\n        return null;\n      var u = B && t[B] || t[S];\n      return typeof u == \"function\" ? u : null;\n    }\n    var O = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function g(t) {\n      {\n        for (var u = arguments.length, p = new Array(u > 1 ? u - 1 : 0), C = 1; C < u; C++)\n          p[C - 1] = arguments[C];\n        X(\"error\", t, p);\n      }\n    }\n    function X(t, u, p) {\n      {\n        var C = O.ReactDebugCurrentFrame, V = C.getStackAddendum();\n        V !== \"\" && (u += \"%s\", p = p.concat([V]));\n        var U = p.map(function(F) {\n          return String(F);\n        });\n        U.unshift(\"Warning: \" + u), Function.prototype.apply.call(console[t], console, U);\n      }\n    }\n    var K = !1, J = !1, ne = !1, fe = !1, ve = !1, ge;\n    ge = Symbol.for(\"react.module.reference\");\n    function Ce(t) {\n      return !!(typeof t == \"string\" || typeof t == \"function\" || t === f || t === j || ve || t === R || t === y || t === m || fe || t === L || K || J || ne || typeof t == \"object\" && t !== null && (t.$$typeof === N || t.$$typeof === E || t.$$typeof === b || t.$$typeof === x || t.$$typeof === h || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      t.$$typeof === ge || t.getModuleId !== void 0));\n    }\n    function Be(t, u, p) {\n      var C = t.displayName;\n      if (C)\n        return C;\n      var V = u.displayName || u.name || \"\";\n      return V !== \"\" ? p + \"(\" + V + \")\" : p;\n    }\n    function Se(t) {\n      return t.displayName || \"Context\";\n    }\n    function ce(t) {\n      if (t == null)\n        return null;\n      if (typeof t.tag == \"number\" && g(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof t == \"function\")\n        return t.displayName || t.name || null;\n      if (typeof t == \"string\")\n        return t;\n      switch (t) {\n        case f:\n          return \"Fragment\";\n        case i:\n          return \"Portal\";\n        case j:\n          return \"Profiler\";\n        case R:\n          return \"StrictMode\";\n        case y:\n          return \"Suspense\";\n        case m:\n          return \"SuspenseList\";\n      }\n      if (typeof t == \"object\")\n        switch (t.$$typeof) {\n          case x:\n            var u = t;\n            return Se(u) + \".Consumer\";\n          case b:\n            var p = t;\n            return Se(p._context) + \".Provider\";\n          case h:\n            return Be(t, t.render, \"ForwardRef\");\n          case E:\n            var C = t.displayName || null;\n            return C !== null ? C : ce(t.type) || \"Memo\";\n          case N: {\n            var V = t, U = V._payload, F = V._init;\n            try {\n              return ce(F(U));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var de = Object.assign, se = 0, he, k, ye, Oe, be, a, d;\n    function D() {\n    }\n    D.__reactDisabledLog = !0;\n    function I() {\n      {\n        if (se === 0) {\n          he = console.log, k = console.info, ye = console.warn, Oe = console.error, be = console.group, a = console.groupCollapsed, d = console.groupEnd;\n          var t = {\n            configurable: !0,\n            enumerable: !0,\n            value: D,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: t,\n            log: t,\n            warn: t,\n            error: t,\n            group: t,\n            groupCollapsed: t,\n            groupEnd: t\n          });\n        }\n        se++;\n      }\n    }\n    function W() {\n      {\n        if (se--, se === 0) {\n          var t = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: de({}, t, {\n              value: he\n            }),\n            info: de({}, t, {\n              value: k\n            }),\n            warn: de({}, t, {\n              value: ye\n            }),\n            error: de({}, t, {\n              value: Oe\n            }),\n            group: de({}, t, {\n              value: be\n            }),\n            groupCollapsed: de({}, t, {\n              value: a\n            }),\n            groupEnd: de({}, t, {\n              value: d\n            })\n          });\n        }\n        se < 0 && g(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var G = O.ReactCurrentDispatcher, H;\n    function z(t, u, p) {\n      {\n        if (H === void 0)\n          try {\n            throw Error();\n          } catch (V) {\n            var C = V.stack.trim().match(/\\n( *(at )?)/);\n            H = C && C[1] || \"\";\n          }\n        return `\n` + H + t;\n      }\n    }\n    var Y = !1, ae;\n    {\n      var xr = typeof WeakMap == \"function\" ? WeakMap : Map;\n      ae = new xr();\n    }\n    function Ze(t, u) {\n      if (!t || Y)\n        return \"\";\n      {\n        var p = ae.get(t);\n        if (p !== void 0)\n          return p;\n      }\n      var C;\n      Y = !0;\n      var V = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var U;\n      U = G.current, G.current = null, I();\n      try {\n        if (u) {\n          var F = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(F.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(F, []);\n            } catch (ue) {\n              C = ue;\n            }\n            Reflect.construct(t, [], F);\n          } else {\n            try {\n              F.call();\n            } catch (ue) {\n              C = ue;\n            }\n            t.call(F.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (ue) {\n            C = ue;\n          }\n          t();\n        }\n      } catch (ue) {\n        if (ue && C && typeof ue.stack == \"string\") {\n          for (var $ = ue.stack.split(`\n`), ie = C.stack.split(`\n`), ee = $.length - 1, te = ie.length - 1; ee >= 1 && te >= 0 && $[ee] !== ie[te]; )\n            te--;\n          for (; ee >= 1 && te >= 0; ee--, te--)\n            if ($[ee] !== ie[te]) {\n              if (ee !== 1 || te !== 1)\n                do\n                  if (ee--, te--, te < 0 || $[ee] !== ie[te]) {\n                    var pe = `\n` + $[ee].replace(\" at new \", \" at \");\n                    return t.displayName && pe.includes(\"<anonymous>\") && (pe = pe.replace(\"<anonymous>\", t.displayName)), typeof t == \"function\" && ae.set(t, pe), pe;\n                  }\n                while (ee >= 1 && te >= 0);\n              break;\n            }\n        }\n      } finally {\n        Y = !1, G.current = U, W(), Error.prepareStackTrace = V;\n      }\n      var we = t ? t.displayName || t.name : \"\", _e = we ? z(we) : \"\";\n      return typeof t == \"function\" && ae.set(t, _e), _e;\n    }\n    function Ie(t, u, p) {\n      return Ze(t, !1);\n    }\n    function _r(t) {\n      var u = t.prototype;\n      return !!(u && u.isReactComponent);\n    }\n    function Me(t, u, p) {\n      if (t == null)\n        return \"\";\n      if (typeof t == \"function\")\n        return Ze(t, _r(t));\n      if (typeof t == \"string\")\n        return z(t);\n      switch (t) {\n        case y:\n          return z(\"Suspense\");\n        case m:\n          return z(\"SuspenseList\");\n      }\n      if (typeof t == \"object\")\n        switch (t.$$typeof) {\n          case h:\n            return Ie(t.render);\n          case E:\n            return Me(t.type, u, p);\n          case N: {\n            var C = t, V = C._payload, U = C._init;\n            try {\n              return Me(U(V), u, p);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var je = Object.prototype.hasOwnProperty, Te = {}, er = O.ReactDebugCurrentFrame;\n    function Pe(t) {\n      if (t) {\n        var u = t._owner, p = Me(t.type, t._source, u ? u.type : null);\n        er.setExtraStackFrame(p);\n      } else\n        er.setExtraStackFrame(null);\n    }\n    function me(t, u, p, C, V) {\n      {\n        var U = Function.call.bind(je);\n        for (var F in t)\n          if (U(t, F)) {\n            var $ = void 0;\n            try {\n              if (typeof t[F] != \"function\") {\n                var ie = Error((C || \"React class\") + \": \" + p + \" type `\" + F + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof t[F] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw ie.name = \"Invariant Violation\", ie;\n              }\n              $ = t[F](u, F, C, p, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (ee) {\n              $ = ee;\n            }\n            $ && !($ instanceof Error) && (Pe(V), g(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", C || \"React class\", p, F, typeof $), Pe(null)), $ instanceof Error && !($.message in Te) && (Te[$.message] = !0, Pe(V), g(\"Failed %s type: %s\", p, $.message), Pe(null));\n          }\n      }\n    }\n    var Ne = Array.isArray;\n    function Le(t) {\n      return Ne(t);\n    }\n    function rr(t) {\n      {\n        var u = typeof Symbol == \"function\" && Symbol.toStringTag, p = u && t[Symbol.toStringTag] || t.constructor.name || \"Object\";\n        return p;\n      }\n    }\n    function tr(t) {\n      try {\n        return We(t), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function We(t) {\n      return \"\" + t;\n    }\n    function ze(t) {\n      if (tr(t))\n        return g(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", rr(t)), We(t);\n    }\n    var Re = O.ReactCurrentOwner, jr = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, nr, ar, $e;\n    $e = {};\n    function Rr(t) {\n      if (je.call(t, \"ref\")) {\n        var u = Object.getOwnPropertyDescriptor(t, \"ref\").get;\n        if (u && u.isReactWarning)\n          return !1;\n      }\n      return t.ref !== void 0;\n    }\n    function Er(t) {\n      if (je.call(t, \"key\")) {\n        var u = Object.getOwnPropertyDescriptor(t, \"key\").get;\n        if (u && u.isReactWarning)\n          return !1;\n      }\n      return t.key !== void 0;\n    }\n    function kr(t, u) {\n      if (typeof t.ref == \"string\" && Re.current && u && Re.current.stateNode !== u) {\n        var p = ce(Re.current.type);\n        $e[p] || (g('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ce(Re.current.type), t.ref), $e[p] = !0);\n      }\n    }\n    function Ee(t, u) {\n      {\n        var p = function() {\n          nr || (nr = !0, g(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", u));\n        };\n        p.isReactWarning = !0, Object.defineProperty(t, \"key\", {\n          get: p,\n          configurable: !0\n        });\n      }\n    }\n    function or(t, u) {\n      {\n        var p = function() {\n          ar || (ar = !0, g(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", u));\n        };\n        p.isReactWarning = !0, Object.defineProperty(t, \"ref\", {\n          get: p,\n          configurable: !0\n        });\n      }\n    }\n    var wr = function(t, u, p, C, V, U, F) {\n      var $ = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: c,\n        // Built-in properties that belong on the element\n        type: t,\n        key: u,\n        ref: p,\n        props: F,\n        // Record the component responsible for creating this element.\n        _owner: U\n      };\n      return $._store = {}, Object.defineProperty($._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty($, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: C\n      }), Object.defineProperty($, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: V\n      }), Object.freeze && (Object.freeze($.props), Object.freeze($)), $;\n    };\n    function Cr(t, u, p, C, V) {\n      {\n        var U, F = {}, $ = null, ie = null;\n        p !== void 0 && (ze(p), $ = \"\" + p), Er(u) && (ze(u.key), $ = \"\" + u.key), Rr(u) && (ie = u.ref, kr(u, V));\n        for (U in u)\n          je.call(u, U) && !jr.hasOwnProperty(U) && (F[U] = u[U]);\n        if (t && t.defaultProps) {\n          var ee = t.defaultProps;\n          for (U in ee)\n            F[U] === void 0 && (F[U] = ee[U]);\n        }\n        if ($ || ie) {\n          var te = typeof t == \"function\" ? t.displayName || t.name || \"Unknown\" : t;\n          $ && Ee(F, te), ie && or(F, te);\n        }\n        return wr(t, $, ie, V, C, Re.current, F);\n      }\n    }\n    var Ve = O.ReactCurrentOwner, sr = O.ReactDebugCurrentFrame;\n    function xe(t) {\n      if (t) {\n        var u = t._owner, p = Me(t.type, t._source, u ? u.type : null);\n        sr.setExtraStackFrame(p);\n      } else\n        sr.setExtraStackFrame(null);\n    }\n    var Ae;\n    Ae = !1;\n    function ke(t) {\n      return typeof t == \"object\" && t !== null && t.$$typeof === c;\n    }\n    function De() {\n      {\n        if (Ve.current) {\n          var t = ce(Ve.current.type);\n          if (t)\n            return `\n\nCheck the render method of \\`` + t + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Sr(t) {\n      return \"\";\n    }\n    var ir = {};\n    function Or(t) {\n      {\n        var u = De();\n        if (!u) {\n          var p = typeof t == \"string\" ? t : t.displayName || t.name;\n          p && (u = `\n\nCheck the top-level render call using <` + p + \">.\");\n        }\n        return u;\n      }\n    }\n    function lr(t, u) {\n      {\n        if (!t._store || t._store.validated || t.key != null)\n          return;\n        t._store.validated = !0;\n        var p = Or(u);\n        if (ir[p])\n          return;\n        ir[p] = !0;\n        var C = \"\";\n        t && t._owner && t._owner !== Ve.current && (C = \" It was passed a child from \" + ce(t._owner.type) + \".\"), xe(t), g('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', p, C), xe(null);\n      }\n    }\n    function cr(t, u) {\n      {\n        if (typeof t != \"object\")\n          return;\n        if (Le(t))\n          for (var p = 0; p < t.length; p++) {\n            var C = t[p];\n            ke(C) && lr(C, u);\n          }\n        else if (ke(t))\n          t._store && (t._store.validated = !0);\n        else if (t) {\n          var V = P(t);\n          if (typeof V == \"function\" && V !== t.entries)\n            for (var U = V.call(t), F; !(F = U.next()).done; )\n              ke(F.value) && lr(F.value, u);\n        }\n      }\n    }\n    function Fe(t) {\n      {\n        var u = t.type;\n        if (u == null || typeof u == \"string\")\n          return;\n        var p;\n        if (typeof u == \"function\")\n          p = u.propTypes;\n        else if (typeof u == \"object\" && (u.$$typeof === h || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        u.$$typeof === E))\n          p = u.propTypes;\n        else\n          return;\n        if (p) {\n          var C = ce(u);\n          me(p, t.props, \"prop\", C, t);\n        } else if (u.PropTypes !== void 0 && !Ae) {\n          Ae = !0;\n          var V = ce(u);\n          g(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", V || \"Unknown\");\n        }\n        typeof u.getDefaultProps == \"function\" && !u.getDefaultProps.isReactClassApproved && g(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function He(t) {\n      {\n        for (var u = Object.keys(t.props), p = 0; p < u.length; p++) {\n          var C = u[p];\n          if (C !== \"children\" && C !== \"key\") {\n            xe(t), g(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", C), xe(null);\n            break;\n          }\n        }\n        t.ref !== null && (xe(t), g(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), xe(null));\n      }\n    }\n    var qe = {};\n    function ur(t, u, p, C, V, U) {\n      {\n        var F = Ce(t);\n        if (!F) {\n          var $ = \"\";\n          (t === void 0 || typeof t == \"object\" && t !== null && Object.keys(t).length === 0) && ($ += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var ie = Sr();\n          ie ? $ += ie : $ += De();\n          var ee;\n          t === null ? ee = \"null\" : Le(t) ? ee = \"array\" : t !== void 0 && t.$$typeof === c ? (ee = \"<\" + (ce(t.type) || \"Unknown\") + \" />\", $ = \" Did you accidentally export a JSX literal instead of a component?\") : ee = typeof t, g(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", ee, $);\n        }\n        var te = Cr(t, u, p, V, U);\n        if (te == null)\n          return te;\n        if (F) {\n          var pe = u.children;\n          if (pe !== void 0)\n            if (C)\n              if (Le(pe)) {\n                for (var we = 0; we < pe.length; we++)\n                  cr(pe[we], t);\n                Object.freeze && Object.freeze(pe);\n              } else\n                g(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              cr(pe, t);\n        }\n        if (je.call(u, \"key\")) {\n          var _e = ce(t), ue = Object.keys(u).filter(function(Ar) {\n            return Ar !== \"key\";\n          }), Ke = ue.length > 0 ? \"{key: someKey, \" + ue.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n          if (!qe[_e + Ke]) {\n            var $r = ue.length > 0 ? \"{\" + ue.join(\": ..., \") + \": ...}\" : \"{}\";\n            g(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`, Ke, _e, $r, _e), qe[_e + Ke] = !0;\n          }\n        }\n        return t === f ? He(te) : Fe(te), te;\n      }\n    }\n    function Tr(t, u, p) {\n      return ur(t, u, p, !0);\n    }\n    function Pr(t, u, p) {\n      return ur(t, u, p, !1);\n    }\n    var Nr = Pr, fr = Tr;\n    Je.Fragment = f, Je.jsx = Nr, Je.jsxs = fr;\n  }()), Je;\n}\n false ? 0 : Ur.exports = Jt();\nvar n = Ur.exports;\nconst an = ({\n  title: s,\n  summary: c,\n  value: i,\n  size: f = 350,\n  background: R = \"#fff\",\n  fgColor: j = \"#00bfff\",\n  bgColor: b = \"#ccc\",\n  textColor: x = \"#000\",\n  labelColor: h = \"#000\",\n  label: y = \"\",\n  padding: m = \"2rem\",\n  percentageTextSize: E = 4,\n  titleTextSize: N = 1.8,\n  summaryTextSize: L = 1\n}) => {\n  const S = f / 2 - 30, P = 2 * Math.PI * S, O = `${i / 100 * P} ${P}`, g = f + 60;\n  return /* @__PURE__ */ n.jsxs(\n    \"div\",\n    {\n      className: \"doughnut-chart-wrapper\",\n      style: {\n        \"--background-color\": R,\n        \"--text-color\": x,\n        \"--padding\": m,\n        \"--title-size\": `${N}rem`,\n        \"--summary-size\": `${L}rem`,\n        \"--bg-color\": b,\n        \"--fg-color\": j,\n        \"--label-color\": h,\n        \"--percentage-size\": `${E}rem`,\n        \"--stroke-dasharray\": O\n      },\n      children: [\n        s && /* @__PURE__ */ n.jsx(\"h2\", { className: \"chart-title\", children: s }),\n        /* @__PURE__ */ n.jsxs(\"div\", { className: \"doughnut-container\", children: [\n          /* @__PURE__ */ n.jsxs(\n            \"svg\",\n            {\n              className: \"svg-container\",\n              \"aria-hidden\": \"true\",\n              viewBox: `0 0 ${g} ${g}`,\n              width: f,\n              children: [\n                /* @__PURE__ */ n.jsx(\n                  \"circle\",\n                  {\n                    className: \"circle-background\",\n                    r: S,\n                    cx: g / 2,\n                    cy: g / 2,\n                    strokeWidth: 60\n                  }\n                ),\n                /* @__PURE__ */ n.jsx(\n                  \"circle\",\n                  {\n                    className: \"circle-foreground\",\n                    r: S,\n                    cx: g / 2,\n                    cy: g / 2,\n                    strokeWidth: 60,\n                    strokeDasharray: O\n                  }\n                ),\n                /* @__PURE__ */ n.jsx(\n                  \"text\",\n                  {\n                    className: \"percentage-text\",\n                    x: g / 2,\n                    y: g / 2,\n                    dominantBaseline: \"middle\",\n                    textAnchor: \"middle\",\n                    fill: x,\n                    children: `${i}%`\n                  }\n                ),\n                y && /* @__PURE__ */ n.jsx(\n                  \"text\",\n                  {\n                    className: \"label-text\",\n                    x: g / 2,\n                    y: g / 2 + 30,\n                    dominantBaseline: \"middle\",\n                    textAnchor: \"middle\",\n                    fill: h,\n                    children: y\n                  }\n                )\n              ]\n            }\n          ),\n          c && /* @__PURE__ */ n.jsx(\"p\", { className: \"chart-summary\", children: c })\n        ] })\n      ]\n    }\n  );\n}, on = ({\n  data: s,\n  colors: c = [\"rgba(0, 123, 255, 0.7)\", \"rgba(255, 0, 123, 0.7)\"],\n  height: i = 400,\n  labelColor: f = \"#000\",\n  width: R,\n  // The width is now passed directly as a prop\n  background: j = \"#fff\",\n  foreground: b = \"#000\"\n}) => {\n  const x = s.flatMap((S) => [S.series1, S.series2]), h = Math.min(...x), y = Math.max(...x), m = (S, P, O, g) => (S - P) / (O - P) * g, E = (S, P, O) => S / P * O, N = (S, P) => {\n    const O = E(P, s.length, i), g = m(S.series1, h, y, R), X = m(S.series2, h, y, R);\n    return /* @__PURE__ */ n.jsxs(\"g\", { children: [\n      /* @__PURE__ */ n.jsx(\n        \"line\",\n        {\n          x1: g,\n          y1: O + i / s.length / 2,\n          x2: X,\n          y2: O + i / s.length / 2,\n          stroke: \"var(--foreground-color)\",\n          strokeWidth: \"2\"\n        }\n      ),\n      /* @__PURE__ */ n.jsx(\"circle\", { cx: g, cy: O + i / s.length / 2, r: 6, fill: c[0] }),\n      /* @__PURE__ */ n.jsx(\"circle\", { cx: X, cy: O + i / s.length / 2, r: 6, fill: c[1] })\n    ] }, `dumbbell-${P}`);\n  }, L = s.map((S, P) => /* @__PURE__ */ n.jsx(\n    \"text\",\n    {\n      x: \"-10\",\n      y: E(P, s.length, i) + i / s.length / 2 + 5,\n      textAnchor: \"end\",\n      fontSize: \"12px\",\n      fill: \"var(--label-color)\",\n      children: S.fruit\n    },\n    P\n  )), B = () => {\n    const P = (y - h) / 5, O = [];\n    for (let g = 0; g < 6; g++) {\n      const X = h + g * P, K = m(X, h, y, R);\n      O.push(\n        /* @__PURE__ */ n.jsxs(\"g\", { children: [\n          /* @__PURE__ */ n.jsx(\n            \"line\",\n            {\n              x1: K,\n              y1: i,\n              x2: K,\n              y2: i + 5,\n              stroke: \"var(--foreground-color)\"\n            }\n          ),\n          /* @__PURE__ */ n.jsx(\n            \"text\",\n            {\n              x: K,\n              y: i + 20,\n              textAnchor: \"middle\",\n              fontSize: \"12px\",\n              fill: \"var(--label-color)\",\n              children: X.toFixed(0)\n            }\n          )\n        ] }, `x-tick-${g}`)\n      );\n    }\n    return O;\n  };\n  return /* @__PURE__ */ n.jsx(\n    \"div\",\n    {\n      className: \"dumbbell-chart-wrapper\",\n      style: {\n        \"--background-color\": j,\n        \"--foreground-color\": b,\n        \"--label-color\": f,\n        \"--chart-height\": `${i}px`\n      },\n      children: /* @__PURE__ */ n.jsx(\"div\", { className: \"svg-container\", children: /* @__PURE__ */ n.jsxs(\n        \"svg\",\n        {\n          viewBox: `0 0 ${R} ${i + 50}`,\n          style: { overflow: \"visible\", width: \"100%\", height: \"100%\" },\n          children: [\n            s.map((S, P) => N(S, P)),\n            L,\n            /* @__PURE__ */ n.jsx(\n              \"line\",\n              {\n                x1: \"0\",\n                y1: i,\n                x2: R,\n                y2: i,\n                stroke: \"var(--foreground-color)\",\n                strokeWidth: \"2\"\n              }\n            ),\n            B()\n          ]\n        }\n      ) })\n    }\n  );\n}, sn = ({\n  title: s,\n  summary: c,\n  ariaDescription: i,\n  labelColor: f = \"#000\",\n  background: R = \"#fff\",\n  foreground: j = \"#000\",\n  data: b\n}) => {\n  const x = Math.max(...b.map((h) => h.value));\n  return /* @__PURE__ */ n.jsx(\"div\", { className: \"comparison-graph\", children: /* @__PURE__ */ n.jsxs(\n    \"div\",\n    {\n      className: \"chart-wrapper\",\n      style: {\n        \"--background-color\": R,\n        \"--foreground-color\": j\n      },\n      children: [\n        /* @__PURE__ */ n.jsx(\n          \"div\",\n          {\n            className: \"title-container\",\n            style: { \"--foreground-color\": j },\n            children: /* @__PURE__ */ n.jsx(\"h2\", { className: \"graph-title\", children: s })\n          }\n        ),\n        /* @__PURE__ */ n.jsx(\"div\", { className: \"graph-container\", \"aria-hidden\": \"true\", children: b.map((h, y) => {\n          const m = Math.sqrt(h.value) / Math.sqrt(x) * 10;\n          return /* @__PURE__ */ n.jsx(\n            \"div\",\n            {\n              className: \"circle-wrapper\",\n              style: {\n                width: `${m}rem`,\n                height: `${m}rem`,\n                \"--circle-color\": h.color\n              },\n              children: /* @__PURE__ */ n.jsxs(\n                \"div\",\n                {\n                  className: \"circle-text\",\n                  style: { \"--label-color\": f },\n                  children: [\n                    h.value,\n                    \"B\"\n                  ]\n                }\n              )\n            },\n            y\n          );\n        }) }),\n        c && /* @__PURE__ */ n.jsx(\"p\", { className: \"graph-summary\", style: { \"--foreground-color\": j }, children: c })\n      ]\n    }\n  ) });\n}, ln = ({\n  title: s,\n  background: c,\n  foreground: i,\n  labelColor: f,\n  summary: R,\n  items: j = [],\n  year: b,\n  valueType: x = \"\",\n  colorSeries: h = []\n  // New prop for color series override\n}) => /* @__PURE__ */ n.jsx(\"div\", { className: \"horizontal-bar\", children: /* @__PURE__ */ n.jsxs(\n  \"ol\",\n  {\n    className: \"list-container\",\n    style: {\n      \"--background-color\": c || \"#0c263eff\"\n    },\n    children: [\n      s && /* @__PURE__ */ n.jsx(\"h2\", { className: \"title\", style: { \"--foreground-color\": i || \"#000\" }, children: s }),\n      R && /* @__PURE__ */ n.jsx(\"p\", { className: \"summary\", style: { \"--foreground-color\": i || \"#000\" }, children: R }),\n      b && /* @__PURE__ */ n.jsxs(\"h3\", { className: \"year-text\", style: { \"--foreground-color\": i || \"#fff\" }, children: [\n        \"Year: \",\n        b\n      ] }),\n      j.length > 0 ? j.map((y, m) => {\n        const E = h[m] || y.color || \"#ccc\";\n        return /* @__PURE__ */ n.jsxs(\"li\", { className: \"list-item\", children: [\n          /* @__PURE__ */ n.jsx(\"p\", { className: \"name-text\", style: { \"--foreground-color\": i || \"#fff\" }, children: y.name }),\n          /* @__PURE__ */ n.jsx(\"div\", { className: \"line-container\", children: /* @__PURE__ */ n.jsx(\n            \"div\",\n            {\n              className: \"line\",\n              style: {\n                \"--line-color\": E,\n                \"--line-width\": `${y.value}%`\n              },\n              children: /* @__PURE__ */ n.jsxs(\"span\", { className: \"total-value\", style: { \"--label-color\": f || \"#fff\" }, children: [\n                y.value,\n                x\n              ] })\n            }\n          ) })\n        ] }, m);\n      }) : /* @__PURE__ */ n.jsx(\"p\", { children: \"No data available\" })\n    ]\n  }\n) }), cn = ({\n  title: s,\n  background: c,\n  foreground: i,\n  summary: f,\n  items: R = [],\n  labelColor: j,\n  valueType: b = \"\",\n  valueColor: x,\n  colors: h\n}) => {\n  const y = [\"#ff6347\", \"#4682b4\", \"#32cd32\", \"#dda0dd\"];\n  return /* @__PURE__ */ n.jsx(\"div\", { className: \"horizontal-list\", children: /* @__PURE__ */ n.jsxs(\n    \"ol\",\n    {\n      className: \"list-container\",\n      style: { \"--background-color\": c || \"#0c263eff\" },\n      children: [\n        s && /* @__PURE__ */ n.jsx(\n          \"h2\",\n          {\n            className: \"title\",\n            style: {\n              \"--foreground-color\": i || \"#000\"\n            },\n            children: s\n          }\n        ),\n        f && /* @__PURE__ */ n.jsx(\n          \"p\",\n          {\n            className: \"summary\",\n            style: {\n              \"--foreground-color\": i || \"#000\"\n            },\n            children: f\n          }\n        ),\n        R.map((m, E) => {\n          const N = m.color || y[E % y.length], L = m.valueColor || x || \"#fff\";\n          return /* @__PURE__ */ n.jsxs(\"li\", { className: \"list-item\", children: [\n            /* @__PURE__ */ n.jsx(\n              \"p\",\n              {\n                className: \"name-text\",\n                style: {\n                  \"--label-color\": j || \"#000\"\n                },\n                children: m.name\n              }\n            ),\n            /* @__PURE__ */ n.jsxs(\"div\", { className: \"line-container\", children: [\n              /* @__PURE__ */ n.jsx(\n                \"div\",\n                {\n                  className: \"line\",\n                  style: {\n                    \"--line-color\": N,\n                    \"--line-width\": `${m.value}%`\n                  }\n                }\n              ),\n              /* @__PURE__ */ n.jsxs(\n                \"div\",\n                {\n                  className: \"circle\",\n                  style: {\n                    \"--circle-color\": N,\n                    \"--value-color\": L\n                  },\n                  children: [\n                    m.value,\n                    b\n                  ]\n                }\n              )\n            ] })\n          ] }, E);\n        })\n      ]\n    }\n  ) });\n}, Br = (s, c, i) => i - s / c * i, jt = (s, c, i) => s / (c - 1) * i, Qt = (s, c, i, f = 5, R = \"#000\") => {\n  const j = [];\n  for (let b = 0; b <= f; b++) {\n    const x = i / f * b, h = Br(x, i, c);\n    j.push(\n      /* @__PURE__ */ n.jsx(\n        \"line\",\n        {\n          x1: \"0\",\n          y1: h,\n          x2: s,\n          y2: h,\n          stroke: R,\n          strokeWidth: \"1\"\n        },\n        `grid-line-${b}`\n      )\n    );\n  }\n  return j;\n}, un = ({\n  data: s,\n  colors: c = [\n    \"rgba(0, 123, 255, 0.5)\",\n    \"rgba(0, 255, 123, 0.5)\",\n    \"rgba(255, 123, 0, 0.5)\"\n  ],\n  height: i = 400,\n  width: f,\n  seriesNames: R = [\"Series 1\", \"Series 2\", \"Series 3\"],\n  background: j = \"#fff\",\n  labelColor: b = \"#000\",\n  axisColor: x = \"#000\"\n}) => {\n  if (!s || s.length === 0)\n    return /* @__PURE__ */ n.jsx(\"p\", { children: \"No data available\" });\n  const h = Math.max(\n    ...s.map((S) => S.series1 + S.series2 + S.series3)\n  ), y = (S, P = []) => {\n    let O = \"\";\n    const g = [...P];\n    return s.forEach((X, K) => {\n      const J = jt(K, s.length, f), ne = X[S] + (P[K] || 0), fe = Br(ne, h, i);\n      O += `${K === 0 ? \"M\" : \"L\"} ${J} ${fe} `, g[K] = ne;\n    }), O += `L ${f} ${i} L 0 ${i} Z`, { path: O, accumulatedValues: g };\n  }, m = y(\"series1\"), E = y(\"series2\", m.accumulatedValues), N = y(\"series3\", E.accumulatedValues), L = s.map((S, P) => /* @__PURE__ */ n.jsx(\n    \"text\",\n    {\n      x: jt(P, s.length, f),\n      y: i + 20,\n      textAnchor: \"middle\",\n      fontSize: \"12px\",\n      fill: x,\n      children: S.month\n    },\n    S.month\n  )), B = Array.from({ length: 6 }, (S, P) => {\n    const O = h / 5 * P, g = Br(O, h, i);\n    return /* @__PURE__ */ n.jsx(\n      \"text\",\n      {\n        x: \"-10\",\n        y: g + 5,\n        textAnchor: \"end\",\n        fontSize: \"12px\",\n        fill: x,\n        children: O.toFixed(0)\n      },\n      `y-label-${P}`\n    );\n  });\n  return /* @__PURE__ */ n.jsxs(\"div\", { className: \"stacked-area-chart\", style: { backgroundColor: j }, children: [\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"svg-container\", children: /* @__PURE__ */ n.jsxs(\n      \"svg\",\n      {\n        viewBox: `0 0 ${f} ${i + 30}`,\n        style: { overflow: \"visible\", width: \"100%\", height: \"100%\" },\n        children: [\n          Qt(f, i, h),\n          /* @__PURE__ */ n.jsx(\"path\", { d: N.path, fill: c[2], stroke: \"none\" }),\n          /* @__PURE__ */ n.jsx(\"path\", { d: E.path, fill: c[1], stroke: \"none\" }),\n          /* @__PURE__ */ n.jsx(\"path\", { d: m.path, fill: c[0], stroke: \"none\" }),\n          L,\n          B,\n          /* @__PURE__ */ n.jsx(\n            \"line\",\n            {\n              x1: \"0\",\n              y1: i,\n              x2: f,\n              y2: i,\n              stroke: x,\n              strokeWidth: \"2\"\n            }\n          ),\n          /* @__PURE__ */ n.jsx(\n            \"line\",\n            {\n              x1: \"0\",\n              y1: \"0\",\n              x2: \"0\",\n              y2: i,\n              stroke: x,\n              strokeWidth: \"2\"\n            }\n          )\n        ]\n      }\n    ) }),\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"legend-container\", children: R.map((S, P) => /* @__PURE__ */ n.jsxs(\"div\", { className: \"legend-item\", style: { color: b }, children: [\n      /* @__PURE__ */ n.jsx(\"div\", { className: \"color-box\", style: { backgroundColor: c[P] } }),\n      /* @__PURE__ */ n.jsx(\"span\", { children: S })\n    ] }, P)) })\n  ] });\n}, Et = (s) => {\n  let c = `M ${s[0].x} ${s[0].y}`;\n  for (let i = 1; i < s.length - 1; i++) {\n    const f = (s[i].x + s[i + 1].x) / 2, R = (s[i].y + s[i + 1].y) / 2, j = (f + s[i].x) / 2, b = (f + s[i + 1].x) / 2;\n    c += ` Q ${j} ${s[i].y}, ${f} ${R} Q ${b} ${s[i + 1].y}, ${s[i + 1].x} ${s[i + 1].y}`;\n  }\n  return c;\n}, Zt = (s, c) => {\n  let i = Et(s);\n  const f = s[s.length - 1];\n  return i += ` L ${f.x} ${c} L ${s[0].x} ${c} Z`, i;\n}, fn = ({\n  data: s,\n  labels: c,\n  width: i = 800,\n  height: f = 400,\n  fillColor: R,\n  strokeColor: j,\n  background: b,\n  labelColor: x,\n  lineColor: h\n}) => {\n  const y = Math.max(...s), m = i / (s.length - 1), E = 20, N = s.map((L, B) => ({\n    x: E + B * m,\n    y: f - L / y * f\n  }));\n  return /* @__PURE__ */ n.jsx(\n    \"div\",\n    {\n      className: \"spline-chart-container\",\n      style: { \"--chart-height\": `${f}px`, \"--chart-background\": b || \"#f9f9f9\" },\n      children: /* @__PURE__ */ n.jsxs(\"svg\", { className: \"svg-container\", viewBox: `0 0 ${i} ${f}`, children: [\n        N.map((L, B) => /* @__PURE__ */ n.jsxs(\"g\", { children: [\n          /* @__PURE__ */ n.jsx(\n            \"line\",\n            {\n              x1: L.x,\n              y1: 0,\n              x2: L.x,\n              y2: f,\n              style: { stroke: h || \"#ccc\" },\n              className: \"vertical-line\"\n            }\n          ),\n          /* @__PURE__ */ n.jsx(\"text\", { x: L.x, y: f - 5, textAnchor: \"middle\", style: { fill: x || \"#333\" }, className: \"axis-label\", children: c[B] })\n        ] }, B)),\n        /* @__PURE__ */ n.jsx(\n          \"path\",\n          {\n            d: Zt(N, f),\n            style: { fill: R || \"#4682b4\" },\n            className: \"area-path\"\n          }\n        ),\n        /* @__PURE__ */ n.jsx(\n          \"path\",\n          {\n            d: Et(N),\n            style: { stroke: j || \"#4682b4\" },\n            className: \"spline-path\"\n          }\n        )\n      ] })\n    }\n  );\n};\nvar en = Hr();\nconst kt = /* @__PURE__ */ qt(en), dn = ({\n  riskData: s,\n  likelihoodLabels: c,\n  impactLabels: i,\n  background: f = \"#fff\",\n  foreground: R = \"#000\",\n  labelColor: j,\n  colors: b\n}) => {\n  const x = (y) => {\n    switch (y) {\n      case \"low\":\n        return b[0];\n      case \"medium\":\n        return b[1];\n      case \"high\":\n        return b[2];\n      default:\n        return \"#fff\";\n    }\n  }, h = (y) => {\n    switch (y) {\n      case \"low\":\n        return j[0];\n      case \"medium\":\n        return j[1];\n      case \"high\":\n        return j[2];\n      default:\n        return \"#333\";\n    }\n  };\n  return /* @__PURE__ */ n.jsxs(\"div\", { children: [\n    /* @__PURE__ */ n.jsx(\"h2\", { className: \"title\", style: { color: R }, children: \"Risk Rating Matrix\" }),\n    /* @__PURE__ */ n.jsxs(\"div\", { className: \"matrix-container\", style: { backgroundColor: f }, children: [\n      /* @__PURE__ */ n.jsx(\"div\", { className: \"axis-label\" }),\n      c.map((y, m) => /* @__PURE__ */ n.jsx(\"div\", { className: \"axis-label\", style: { color: R }, children: y }, m)),\n      s.map((y, m) => /* @__PURE__ */ n.jsxs(kt.Fragment, { children: [\n        /* @__PURE__ */ n.jsx(\"div\", { className: \"axis-label\", style: { color: R }, children: i[m] }),\n        y.map((E, N) => /* @__PURE__ */ n.jsx(\n          \"div\",\n          {\n            className: \"matrix-cell\",\n            style: {\n              backgroundColor: x(E),\n              color: h(E)\n            },\n            children: E.charAt(0).toUpperCase() + E.slice(1)\n          },\n          `${m}-${N}`\n        ))\n      ] }, m))\n    ] })\n  ] });\n}, rn = (s) => {\n  const c = Math.min(255, Math.floor(255 * s / 100)), i = Math.min(255, Math.floor(255 * (100 - s) / 100));\n  return `rgb(${c}, 0, ${i})`;\n}, pn = ({\n  data: s,\n  months: c,\n  rowLabels: i,\n  background: f,\n  labelColor: R,\n  valueColor: j\n}) => {\n  const b = i.length, x = c.length;\n  return /* @__PURE__ */ n.jsxs(\"div\", { className: \"heatmap-wrapper\", style: { backgroundColor: f, \"--num-columns\": x, \"--num-rows\": b }, children: [\n    /* @__PURE__ */ n.jsx(\"div\", {}),\n    c.map((h, y) => /* @__PURE__ */ n.jsx(\"div\", { className: \"date-label\", style: { color: R }, children: h }, y)),\n    s.map((h, y) => /* @__PURE__ */ n.jsxs(kt.Fragment, { children: [\n      /* @__PURE__ */ n.jsx(\"div\", { className: \"row-label\", style: { color: R }, children: i[y] }),\n      h.map((m, E) => /* @__PURE__ */ n.jsx(\n        \"div\",\n        {\n          className: \"heatmap-cell\",\n          style: { backgroundColor: rn(m), color: j },\n          children: m\n        },\n        E\n      ))\n    ] }, y))\n  ] });\n}, vn = ({\n  data: s,\n  legend: c,\n  background: i,\n  textColor: f,\n  defaultColors: R,\n  explanation: j,\n  barWidth: b = \"90%\"\n}) => /* @__PURE__ */ n.jsx(\"div\", { className: \"stacked-row-chart\", children: /* @__PURE__ */ n.jsxs(\"div\", { className: \"chart-container\", style: { backgroundColor: i }, children: [\n  /* @__PURE__ */ n.jsxs(\"div\", { className: \"legend-explanation-container\", children: [\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"explanation-text\", style: { color: f }, children: j }),\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"legend-container\", children: c.map((x, h) => /* @__PURE__ */ n.jsxs(\"div\", { className: \"legend-item\", style: { color: f }, children: [\n      /* @__PURE__ */ n.jsx(\"div\", { className: \"color-box\", style: { backgroundColor: x.color } }),\n      x.label\n    ] }, h)) })\n  ] }),\n  s.map((x, h) => /* @__PURE__ */ n.jsxs(\"div\", { className: \"row\", children: [\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"description\", style: { color: f }, children: x.description }),\n    /* @__PURE__ */ n.jsxs(\"div\", { className: \"bar-container\", style: { backgroundColor: i, width: b }, children: [\n      x.segments.map((y, m) => /* @__PURE__ */ n.jsxs(\n        \"div\",\n        {\n          className: \"bar-segment\",\n          style: { flex: y.value, backgroundColor: y.color || R[m], color: y.textColor || \"#fff\" },\n          children: [\n            y.value,\n            \"%\"\n          ]\n        },\n        m\n      )),\n      /* @__PURE__ */ n.jsx(\"div\", { className: \"bar-value\", style: { color: f } })\n    ] })\n  ] }, h))\n] }) }), zr = (s, c, i) => s == null ? 0 : i - s / c * i, Rt = (s, c, i) => s / c * i, tn = (s = \"#000\", c, i, f, R = 5) => {\n  const j = [];\n  for (let b = 0; b <= R; b++) {\n    const x = f / R * b, h = zr(x, f, i);\n    j.push(\n      /* @__PURE__ */ n.jsx(\n        \"line\",\n        {\n          x1: \"0\",\n          y1: h,\n          x2: c,\n          y2: h,\n          stroke: s,\n          strokeWidth: \"1\"\n        },\n        `grid-line-${b}`\n      )\n    );\n  }\n  return j;\n}, hn = ({\n  data: s,\n  colors: c = [\"rgba(0, 123, 255, 0.7)\", \"rgba(0, 255, 123, 0.7)\", \"rgba(255, 123, 0, 0.7)\"],\n  height: i = 400,\n  width: f,\n  // Width is now required and passed from the parent component\n  seriesNames: R = [\"Series 1\", \"Series 2\", \"Series 3\"],\n  background: j,\n  foreground: b,\n  labelColor: x,\n  valueColor: h,\n  axisColor: y\n}) => {\n  if (!s || s.length === 0)\n    return /* @__PURE__ */ n.jsx(\"p\", { children: \"No data available\" });\n  const m = Math.max(\n    ...s.map(\n      (O) => Object.values(O).filter((g) => typeof g == \"number\").reduce((g, X) => g + X, 0)\n    )\n  ), E = f / s.length / 2, N = f / s.length, L = (O, g) => {\n    let X = 0;\n    return Object.keys(O).map((K, J) => {\n      if (K === \"month\") return null;\n      const ne = O[K], fe = Rt(g, s.length, f) + N / 4, ve = i - zr(ne, m, i), ge = i - ve - X;\n      return X += ve, /* @__PURE__ */ n.jsx(\n        \"rect\",\n        {\n          x: fe,\n          y: ge,\n          width: E,\n          height: ve,\n          fill: c[J - 1]\n        },\n        `${K}-${g}`\n      );\n    });\n  }, B = s.map((O, g) => /* @__PURE__ */ n.jsx(\n    \"text\",\n    {\n      x: Rt(g, s.length, f) + N / 2,\n      y: i + 20,\n      textAnchor: \"middle\",\n      fontSize: \"12px\",\n      fill: y,\n      children: O.month\n    },\n    g\n  )), S = 5, P = Array.from({ length: S + 1 }, (O, g) => {\n    const X = m / S * g, K = zr(X, m, i);\n    return /* @__PURE__ */ n.jsx(\n      \"text\",\n      {\n        x: \"-10\",\n        y: K + 5,\n        textAnchor: \"end\",\n        fontSize: \"12px\",\n        fill: y,\n        children: X.toFixed(0)\n      },\n      `y-label-${g}`\n    );\n  });\n  return /* @__PURE__ */ n.jsxs(\"div\", { className: \"stacked-bar-chart\", style: { backgroundColor: j }, children: [\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"svg-container\", children: /* @__PURE__ */ n.jsxs(\n      \"svg\",\n      {\n        viewBox: `0 0 ${f} ${i + 30}`,\n        style: { overflow: \"visible\", width: \"100%\", height: \"100%\" },\n        children: [\n          tn(y || \"#000\", f, i, m, S),\n          s.map((O, g) => /* @__PURE__ */ n.jsx(\"g\", { children: L(O, g) }, `bar-group-${g}`)),\n          B,\n          P,\n          /* @__PURE__ */ n.jsx(\n            \"line\",\n            {\n              x1: \"0\",\n              y1: i,\n              x2: f,\n              y2: i,\n              stroke: y,\n              strokeWidth: \"2\"\n            }\n          ),\n          /* @__PURE__ */ n.jsx(\n            \"line\",\n            {\n              x1: \"0\",\n              y1: \"0\",\n              x2: \"0\",\n              y2: i,\n              stroke: y || \"#000\",\n              strokeWidth: \"2\"\n            }\n          )\n        ]\n      }\n    ) }),\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"legend-container\", children: R.map((O, g) => /* @__PURE__ */ n.jsxs(\"div\", { className: \"legend-item\", style: { color: x }, children: [\n      /* @__PURE__ */ n.jsx(\"div\", { className: \"color-box\", style: { backgroundColor: c[g] } }),\n      /* @__PURE__ */ n.jsx(\"span\", { children: O })\n    ] }, g)) })\n  ] });\n}, yn = ({\n  data: s,\n  title: c,\n  background: i = \"\",\n  foreground: f = \"\",\n  barColor: R = \"\",\n  targetColor: j = \"\"\n}) => /* @__PURE__ */ n.jsxs(\n  \"div\",\n  {\n    className: \"benchmark-container\",\n    style: {\n      \"--background-color\": i,\n      \"--foreground-color\": f\n    },\n    children: [\n      c && /* @__PURE__ */ n.jsx(\"h2\", { className: \"chart-title\", children: c }),\n      s.map((b, x) => /* @__PURE__ */ n.jsxs(\"div\", { className: \"bar-container\", children: [\n        /* @__PURE__ */ n.jsx(\"div\", { className: \"bar-label\", children: b.label }),\n        /* @__PURE__ */ n.jsxs(\"div\", { style: { flexBasis: \"70%\", position: \"relative\" }, children: [\n          /* @__PURE__ */ n.jsx(\n            \"div\",\n            {\n              className: \"benchmark-line\",\n              \"data-label\": `Target: ${b.benchmark}%`,\n              style: {\n                \"--benchmark-color\": j,\n                \"--benchmark-percentage\": `${b.benchmark}%`\n              }\n            }\n          ),\n          /* @__PURE__ */ n.jsx(\n            \"div\",\n            {\n              className: \"bar\",\n              style: {\n                width: `${b.actual}%`,\n                \"--bar-color\": R\n              }\n            }\n          )\n        ] }),\n        /* @__PURE__ */ n.jsxs(\"div\", { style: { flexBasis: \"10%\", textAlign: \"right\" }, children: [\n          b.actual,\n          \"%\"\n        ] })\n      ] }, x))\n    ]\n  }\n), mn = ({\n  title: s,\n  percentage: c,\n  background: i = \"#fff\",\n  foreground: f = \"#000\",\n  description: R = \"\",\n  activeColor: j = \"#4caf50\",\n  nonActiveColor: b = \"#ccc\",\n  size: x = 100\n}) => {\n  const y = Math.floor(c / 100 * 100), m = Array.from({ length: 100 }, (E, N) => /* @__PURE__ */ n.jsx(\n    \"svg\",\n    {\n      className: \"man-icon\",\n      style: {\n        fill: N >= 100 - y ? j : b\n      },\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 100 210\",\n      width: x,\n      children: /* @__PURE__ */ n.jsx(\"path\", { d: \"M50.28 8.44a19.506 19.97 0 0 0-19.507 19.97 19.506 19.97 0 0 0 11.97 18.406c-10.63.806-19.743 3.327-21.03 7.332L3.596 116.68c-1.376 4.744 1.146 9.597 5.655 10.88l1.903.545c4.508 1.283 9.248-1.509 10.622-6.252l9.194-40.67c-2.654 33.322-2.41 77.242-3.682 112.724-.179 4.935 3.459 9.018 8.144 9.163l1.975.066c4.685.159 8.605-3.713 8.782-8.648l1.943-67.479h3.497l1.943 67.479c.179 4.935 4.086 8.792 8.772 8.648l1.984-.066c4.686-.16 8.311-4.228 8.134-9.163-1.677-32.128-.796-80.335-4.421-110.41l11.147 38.664c1.375 4.743 6.103 7.525 10.612 6.242l1.902-.545c4.51-1.283 7.04-6.126 5.666-10.869l-18.13-62.543c-2.114-4.363-11.125-6.837-21.42-7.63a19.506 19.97 0 0 0 11.97-18.407A19.506 19.97 0 0 0 50.28 8.44Z\" })\n    },\n    N\n  )).reverse();\n  return /* @__PURE__ */ n.jsxs(\"div\", { className: \"waffle-chart-container\", style: { backgroundColor: i }, children: [\n    /* @__PURE__ */ n.jsx(\"h2\", { className: \"waffle-title\", style: { color: f }, children: s }),\n    /* @__PURE__ */ n.jsx(\"p\", { className: \"description\", style: { color: f }, children: R }),\n    /* @__PURE__ */ n.jsxs(\"div\", { className: \"chart-content\", children: [\n      /* @__PURE__ */ n.jsx(\"span\", { role: \"img\", \"aria-label\": `the pictograph of 100 stick people, with ${c} showing as active`, children: /* @__PURE__ */ n.jsx(\"div\", { className: \"waffle-container\", children: m }) }),\n      /* @__PURE__ */ n.jsxs(\"div\", { className: \"percentage-container\", style: { color: j }, children: [\n        c,\n        \"%\"\n      ] })\n    ] })\n  ] });\n}, gn = ({\n  title: s,\n  data: c,\n  fillColor: i = \"#4682b4\",\n  // Default fill color for bars\n  backgroundColor: f = \"#fff\",\n  // Default background color\n  foregroundColor: R = \"#000\",\n  // Default foreground color\n  noTotal: j = !1\n}) => {\n  if (!c || c.length === 0) return /* @__PURE__ */ n.jsx(\"p\", { children: \"No data available\" });\n  const b = c.reduce((E, { value: N }) => E + N, 0), x = 300, h = 50, y = Math.max(...c.map((E) => E.value)), m = x / c.length;\n  return /* @__PURE__ */ n.jsxs(\n    \"div\",\n    {\n      className: \"sparkbar-chart-container\",\n      style: { backgroundColor: f, color: R },\n      children: [\n        !j && /* @__PURE__ */ n.jsxs(n.Fragment, { children: [\n          /* @__PURE__ */ n.jsx(\"div\", { className: \"sparkbar-title\", children: s }),\n          /* @__PURE__ */ n.jsx(\"p\", { className: \"sparkbar-total\", children: b })\n        ] }),\n        /* @__PURE__ */ n.jsx(\"svg\", { className: \"sparkbar-svg\", width: x, height: h, children: c.map((E, N) => /* @__PURE__ */ n.jsx(\n          \"rect\",\n          {\n            className: \"sparkbar-rect\",\n            x: N * m,\n            y: h - E.value / y * h,\n            width: m - 2,\n            height: E.value / y * h,\n            fill: i\n          },\n          N\n        )) })\n      ]\n    }\n  );\n}, bn = ({\n  title: s,\n  total: c,\n  value: i,\n  barColor: f = \"#4682b4\",\n  // Default fill color for the bar\n  background: R = \"#e0e0e0\",\n  // Default background color of the wrapper\n  foreground: j = \"#000\",\n  // Default text color for title and value\n  suffix: b = \"\"\n  // Optional suffix, default is an empty string\n}) => {\n  const x = i / c * 100;\n  return /* @__PURE__ */ n.jsxs(\"div\", { className: \"spark-horizontal-bar-container\", style: { color: j }, children: [\n    /* @__PURE__ */ n.jsxs(\"div\", { className: \"spark-horizontal-bar-info\", children: [\n      /* @__PURE__ */ n.jsx(\"span\", { className: \"spark-horizontal-bar-title\", children: s }),\n      /* @__PURE__ */ n.jsxs(\"span\", { className: \"spark-horizontal-bar-value\", children: [\n        i,\n        b\n      ] })\n    ] }),\n    /* @__PURE__ */ n.jsx(\"div\", { className: \"spark-horizontal-bar-wrapper\", style: { background: R }, children: /* @__PURE__ */ n.jsx(\n      \"div\",\n      {\n        className: \"spark-horizontal-bar-fill\",\n        style: {\n          width: `${x}%`,\n          backgroundColor: f\n        }\n      }\n    ) })\n  ] });\n}, nn = (s) => {\n  if (!s || s.length === 0) return \"\";\n  let c = `M ${s[0].x} ${s[0].y}`;\n  for (let i = 1; i < s.length - 1; i++) {\n    const f = (s[i].x + s[i + 1].x) / 2, R = (s[i].y + s[i + 1].y) / 2, j = (f + s[i].x) / 2, b = (f + s[i + 1].x) / 2;\n    c += ` Q ${j} ${s[i].y}, ${f} ${R} Q ${b} ${s[i + 1].y}, ${s[i + 1].x} ${s[i + 1].y}`;\n  }\n  return c;\n}, xn = ({\n  title: s,\n  data: c,\n  // Data array of objects with item and value\n  strokeColor: i = \"#4682b4\",\n  // Default stroke color\n  strokeWidth: f = 2,\n  // Default stroke width\n  backgroundColor: R = \"#fff\",\n  // Default background color (white)\n  foregroundColor: j = \"#000\"\n  // Default foreground color (black)\n}) => {\n  if (!c || c.length === 0) return /* @__PURE__ */ n.jsx(\"p\", { children: \"No data available\" });\n  const b = c.reduce((B, { value: S }) => B + S, 0), x = 300, h = 50, y = Math.max(...c.map((B) => B.value));\n  if (y === 0) return /* @__PURE__ */ n.jsx(\"p\", { children: \"No valid data\" });\n  const m = x / Math.max(1, c.length - 1), E = f / 2, N = c.map((B, S) => ({\n    x: E + S * m,\n    y: h - B.value / y * h\n  })), L = x + E;\n  return /* @__PURE__ */ n.jsxs(\n    \"div\",\n    {\n      className: \"sparkline-chart-container\",\n      style: { backgroundColor: R, color: j },\n      children: [\n        /* @__PURE__ */ n.jsx(\"div\", { className: \"sparkline-title\", children: s }),\n        /* @__PURE__ */ n.jsx(\"p\", { className: \"sparkline-total\", children: b }),\n        /* @__PURE__ */ n.jsx(\n          \"svg\",\n          {\n            className: \"sparkline-svg\",\n            viewBox: `0 0 ${L} ${h}`,\n            preserveAspectRatio: \"none\",\n            children: /* @__PURE__ */ n.jsx(\n              \"path\",\n              {\n                d: nn(N),\n                className: \"sparkline-path\",\n                style: {\n                  stroke: i,\n                  strokeWidth: f\n                }\n              }\n            )\n          }\n        )\n      ]\n    }\n  );\n}, _n = ({\n  title: s,\n  total: c,\n  segments: i,\n  background: f = \"#e0e0e0\",\n  // Default background color of the wrapper\n  foreground: R = \"#000\",\n  // Default text color for title and value\n  suffix: j = \"\",\n  // Optional suffix, default is an empty string\n  height: b = \"20px\"\n  // Default height for the stacked bar, can be overridden\n}) => /* @__PURE__ */ n.jsxs(\"div\", { className: \"spark-stacked-bar-container\", style: { color: R, background: f }, children: [\n  /* @__PURE__ */ n.jsxs(\"div\", { className: \"spark-stacked-bar-info\", children: [\n    /* @__PURE__ */ n.jsx(\"span\", { className: \"spark-stacked-bar-title\", children: s }),\n    /* @__PURE__ */ n.jsxs(\"span\", { className: \"spark-stacked-bar-value\", children: [\n      i.reduce((x, h) => x + h.value, 0),\n      j\n    ] })\n  ] }),\n  /* @__PURE__ */ n.jsx(\"div\", { className: \"spark-stacked-bar-wrapper\", style: { background: f, height: b }, children: i.map((x, h) => {\n    const y = x.value / c * 100;\n    return /* @__PURE__ */ n.jsx(\n      \"div\",\n      {\n        className: \"spark-stacked-bar-segment\",\n        style: {\n          width: `${y}%`,\n          backgroundColor: x.color,\n          height: \"100%\"\n          // Ensures the segment respects the wrapper's height\n        }\n      },\n      h\n    );\n  }) })\n] });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5mb2NoYXJ0cy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhLFNBQVMsU0FBUyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNILEdBQUc7QUFDSCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZSxTQUFTO0FBQzdGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtRUFBbUUsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxzQkFBc0I7QUFDaEcsMEpBQTBKLGtDQUFrQztBQUM1TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWUsU0FBUyxrQkFBa0IsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSCxpQkFBaUIsMklBQTJJLGlCQUFpQiwwQkFBMEI7QUFDdk0sR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYTtBQUNiLEdBQUc7QUFDSCxhQUFhO0FBQ2IsR0FBRztBQUNILGFBQWEseUJBQXlCLHlCQUF5QjtBQUMvRCxHQUFHO0FBQ0gsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLE9BQU8sU0FBUztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IsbUJBQW1CLFdBQVc7QUFDOUIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsV0FBVztBQUM5QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsV0FBVztBQUM5QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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YUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0VBQWdFLCtCQUErQjtBQUMvRiwyQkFBMkIsVUFBVTtBQUNyQyxtREFBbUQsMkJBQTJCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRixxQ0FBcUMsMkNBQTJDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEdBQUcsRUFBRSxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUNBQXFDLG1EQUFtRCx5QkFBeUI7QUFDbEgsa0NBQWtDO0FBQ2xDLG9DQUFvQyxtREFBbUQ7QUFDdkYscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGlDQUFpQyxpREFBaUQsMEJBQTBCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHLEdBQUc7QUFDTixHQUFHO0FBbUJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5mb3Rlc3QvLi9ub2RlX21vZHVsZXMvaW5mb2NoYXJ0cy9kaXN0L2luZGV4LmVzLmpzPzg2ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcXQocykge1xuICByZXR1cm4gcyAmJiBzLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIFwiZGVmYXVsdFwiKSA/IHMuZGVmYXVsdCA6IHM7XG59XG52YXIgVXIgPSB7IGV4cG9ydHM6IHt9IH0sIFhlID0ge30sIGJyID0geyBleHBvcnRzOiB7fSB9LCBBID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgbXQ7XG5mdW5jdGlvbiBLdCgpIHtcbiAgaWYgKG10KSByZXR1cm4gQTtcbiAgbXQgPSAxO1xuICB2YXIgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgZiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgUiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgaiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgYiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCB4ID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCB5ID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgRSA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgZnVuY3Rpb24gTihhKSB7XG4gICAgcmV0dXJuIGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT0gXCJvYmplY3RcIiA/IG51bGwgOiAoYSA9IEUgJiYgYVtFXSB8fCBhW1wiQEBpdGVyYXRvclwiXSwgdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYSA6IG51bGwpO1xuICB9XG4gIHZhciBMID0geyBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMTtcbiAgfSwgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgfSwgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24oKSB7XG4gIH0sIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gIH0gfSwgQiA9IE9iamVjdC5hc3NpZ24sIFMgPSB7fTtcbiAgZnVuY3Rpb24gUChhLCBkLCBEKSB7XG4gICAgdGhpcy5wcm9wcyA9IGEsIHRoaXMuY29udGV4dCA9IGQsIHRoaXMucmVmcyA9IFMsIHRoaXMudXBkYXRlciA9IEQgfHwgTDtcbiAgfVxuICBQLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge30sIFAucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oYSwgZCkge1xuICAgIGlmICh0eXBlb2YgYSAhPSBcIm9iamVjdFwiICYmIHR5cGVvZiBhICE9IFwiZnVuY3Rpb25cIiAmJiBhICE9IG51bGwpIHRocm93IEVycm9yKFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIpO1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgYSwgZCwgXCJzZXRTdGF0ZVwiKTtcbiAgfSwgUC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihhKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBhLCBcImZvcmNlVXBkYXRlXCIpO1xuICB9O1xuICBmdW5jdGlvbiBPKCkge1xuICB9XG4gIE8ucHJvdG90eXBlID0gUC5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGcoYSwgZCwgRCkge1xuICAgIHRoaXMucHJvcHMgPSBhLCB0aGlzLmNvbnRleHQgPSBkLCB0aGlzLnJlZnMgPSBTLCB0aGlzLnVwZGF0ZXIgPSBEIHx8IEw7XG4gIH1cbiAgdmFyIFggPSBnLnByb3RvdHlwZSA9IG5ldyBPKCk7XG4gIFguY29uc3RydWN0b3IgPSBnLCBCKFgsIFAucHJvdG90eXBlKSwgWC5pc1B1cmVSZWFjdENvbXBvbmVudCA9ICEwO1xuICB2YXIgSyA9IEFycmF5LmlzQXJyYXksIEogPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBuZSA9IHsgY3VycmVudDogbnVsbCB9LCBmZSA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIHZlKGEsIGQsIEQpIHtcbiAgICB2YXIgSSwgVyA9IHt9LCBHID0gbnVsbCwgSCA9IG51bGw7XG4gICAgaWYgKGQgIT0gbnVsbCkgZm9yIChJIGluIGQucmVmICE9PSB2b2lkIDAgJiYgKEggPSBkLnJlZiksIGQua2V5ICE9PSB2b2lkIDAgJiYgKEcgPSBcIlwiICsgZC5rZXkpLCBkKSBKLmNhbGwoZCwgSSkgJiYgIWZlLmhhc093blByb3BlcnR5KEkpICYmIChXW0ldID0gZFtJXSk7XG4gICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAoeiA9PT0gMSkgVy5jaGlsZHJlbiA9IEQ7XG4gICAgZWxzZSBpZiAoMSA8IHopIHtcbiAgICAgIGZvciAodmFyIFkgPSBBcnJheSh6KSwgYWUgPSAwOyBhZSA8IHo7IGFlKyspIFlbYWVdID0gYXJndW1lbnRzW2FlICsgMl07XG4gICAgICBXLmNoaWxkcmVuID0gWTtcbiAgICB9XG4gICAgaWYgKGEgJiYgYS5kZWZhdWx0UHJvcHMpIGZvciAoSSBpbiB6ID0gYS5kZWZhdWx0UHJvcHMsIHopIFdbSV0gPT09IHZvaWQgMCAmJiAoV1tJXSA9IHpbSV0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBzLCB0eXBlOiBhLCBrZXk6IEcsIHJlZjogSCwgcHJvcHM6IFcsIF9vd25lcjogbmUuY3VycmVudCB9O1xuICB9XG4gIGZ1bmN0aW9uIGdlKGEsIGQpIHtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogcywgdHlwZTogYS50eXBlLCBrZXk6IGQsIHJlZjogYS5yZWYsIHByb3BzOiBhLnByb3BzLCBfb3duZXI6IGEuX293bmVyIH07XG4gIH1cbiAgZnVuY3Rpb24gQ2UoYSkge1xuICAgIHJldHVybiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwgJiYgYS4kJHR5cGVvZiA9PT0gcztcbiAgfVxuICBmdW5jdGlvbiBCZShhKSB7XG4gICAgdmFyIGQgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgICByZXR1cm4gXCIkXCIgKyBhLnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24oRCkge1xuICAgICAgcmV0dXJuIGRbRF07XG4gICAgfSk7XG4gIH1cbiAgdmFyIFNlID0gL1xcLysvZztcbiAgZnVuY3Rpb24gY2UoYSwgZCkge1xuICAgIHJldHVybiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwgJiYgYS5rZXkgIT0gbnVsbCA/IEJlKFwiXCIgKyBhLmtleSkgOiBkLnRvU3RyaW5nKDM2KTtcbiAgfVxuICBmdW5jdGlvbiBkZShhLCBkLCBELCBJLCBXKSB7XG4gICAgdmFyIEcgPSB0eXBlb2YgYTtcbiAgICAoRyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBHID09PSBcImJvb2xlYW5cIikgJiYgKGEgPSBudWxsKTtcbiAgICB2YXIgSCA9ICExO1xuICAgIGlmIChhID09PSBudWxsKSBIID0gITA7XG4gICAgZWxzZSBzd2l0Y2ggKEcpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgSCA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgc3dpdGNoIChhLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgIEggPSAhMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoSCkgcmV0dXJuIEggPSBhLCBXID0gVyhIKSwgYSA9IEkgPT09IFwiXCIgPyBcIi5cIiArIGNlKEgsIDApIDogSSwgSyhXKSA/IChEID0gXCJcIiwgYSAhPSBudWxsICYmIChEID0gYS5yZXBsYWNlKFNlLCBcIiQmL1wiKSArIFwiL1wiKSwgZGUoVywgZCwgRCwgXCJcIiwgZnVuY3Rpb24oYWUpIHtcbiAgICAgIHJldHVybiBhZTtcbiAgICB9KSkgOiBXICE9IG51bGwgJiYgKENlKFcpICYmIChXID0gZ2UoVywgRCArICghVy5rZXkgfHwgSCAmJiBILmtleSA9PT0gVy5rZXkgPyBcIlwiIDogKFwiXCIgKyBXLmtleSkucmVwbGFjZShTZSwgXCIkJi9cIikgKyBcIi9cIikgKyBhKSksIGQucHVzaChXKSksIDE7XG4gICAgaWYgKEggPSAwLCBJID0gSSA9PT0gXCJcIiA/IFwiLlwiIDogSSArIFwiOlwiLCBLKGEpKSBmb3IgKHZhciB6ID0gMDsgeiA8IGEubGVuZ3RoOyB6KyspIHtcbiAgICAgIEcgPSBhW3pdO1xuICAgICAgdmFyIFkgPSBJICsgY2UoRywgeik7XG4gICAgICBIICs9IGRlKEcsIGQsIEQsIFksIFcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChZID0gTihhKSwgdHlwZW9mIFkgPT0gXCJmdW5jdGlvblwiKSBmb3IgKGEgPSBZLmNhbGwoYSksIHogPSAwOyAhKEcgPSBhLm5leHQoKSkuZG9uZTsgKSBHID0gRy52YWx1ZSwgWSA9IEkgKyBjZShHLCB6KyspLCBIICs9IGRlKEcsIGQsIEQsIFksIFcpO1xuICAgIGVsc2UgaWYgKEcgPT09IFwib2JqZWN0XCIpIHRocm93IGQgPSBTdHJpbmcoYSksIEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChkID09PSBcIltvYmplY3QgT2JqZWN0XVwiID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKSArIFwifVwiIDogZCkgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIEg7XG4gIH1cbiAgZnVuY3Rpb24gc2UoYSwgZCwgRCkge1xuICAgIGlmIChhID09IG51bGwpIHJldHVybiBhO1xuICAgIHZhciBJID0gW10sIFcgPSAwO1xuICAgIHJldHVybiBkZShhLCBJLCBcIlwiLCBcIlwiLCBmdW5jdGlvbihHKSB7XG4gICAgICByZXR1cm4gZC5jYWxsKEQsIEcsIFcrKyk7XG4gICAgfSksIEk7XG4gIH1cbiAgZnVuY3Rpb24gaGUoYSkge1xuICAgIGlmIChhLl9zdGF0dXMgPT09IC0xKSB7XG4gICAgICB2YXIgZCA9IGEuX3Jlc3VsdDtcbiAgICAgIGQgPSBkKCksIGQudGhlbihmdW5jdGlvbihEKSB7XG4gICAgICAgIChhLl9zdGF0dXMgPT09IDAgfHwgYS5fc3RhdHVzID09PSAtMSkgJiYgKGEuX3N0YXR1cyA9IDEsIGEuX3Jlc3VsdCA9IEQpO1xuICAgICAgfSwgZnVuY3Rpb24oRCkge1xuICAgICAgICAoYS5fc3RhdHVzID09PSAwIHx8IGEuX3N0YXR1cyA9PT0gLTEpICYmIChhLl9zdGF0dXMgPSAyLCBhLl9yZXN1bHQgPSBEKTtcbiAgICAgIH0pLCBhLl9zdGF0dXMgPT09IC0xICYmIChhLl9zdGF0dXMgPSAwLCBhLl9yZXN1bHQgPSBkKTtcbiAgICB9XG4gICAgaWYgKGEuX3N0YXR1cyA9PT0gMSkgcmV0dXJuIGEuX3Jlc3VsdC5kZWZhdWx0O1xuICAgIHRocm93IGEuX3Jlc3VsdDtcbiAgfVxuICB2YXIgayA9IHsgY3VycmVudDogbnVsbCB9LCB5ZSA9IHsgdHJhbnNpdGlvbjogbnVsbCB9LCBPZSA9IHsgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogaywgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IHllLCBSZWFjdEN1cnJlbnRPd25lcjogbmUgfTtcbiAgZnVuY3Rpb24gYmUoKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJhY3QoLi4uKSBpcyBub3Qgc3VwcG9ydGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIFJlYWN0LlwiKTtcbiAgfVxuICByZXR1cm4gQS5DaGlsZHJlbiA9IHsgbWFwOiBzZSwgZm9yRWFjaDogZnVuY3Rpb24oYSwgZCwgRCkge1xuICAgIHNlKGEsIGZ1bmN0aW9uKCkge1xuICAgICAgZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIEQpO1xuICB9LCBjb3VudDogZnVuY3Rpb24oYSkge1xuICAgIHZhciBkID0gMDtcbiAgICByZXR1cm4gc2UoYSwgZnVuY3Rpb24oKSB7XG4gICAgICBkKys7XG4gICAgfSksIGQ7XG4gIH0sIHRvQXJyYXk6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gc2UoYSwgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSkgfHwgW107XG4gIH0sIG9ubHk6IGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoIUNlKGEpKSB0aHJvdyBFcnJvcihcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiKTtcbiAgICByZXR1cm4gYTtcbiAgfSB9LCBBLkNvbXBvbmVudCA9IFAsIEEuRnJhZ21lbnQgPSBpLCBBLlByb2ZpbGVyID0gUiwgQS5QdXJlQ29tcG9uZW50ID0gZywgQS5TdHJpY3RNb2RlID0gZiwgQS5TdXNwZW5zZSA9IGgsIEEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBPZSwgQS5hY3QgPSBiZSwgQS5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbihhLCBkLCBEKSB7XG4gICAgaWYgKGEgPT0gbnVsbCkgdGhyb3cgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGEgKyBcIi5cIik7XG4gICAgdmFyIEkgPSBCKHt9LCBhLnByb3BzKSwgVyA9IGEua2V5LCBHID0gYS5yZWYsIEggPSBhLl9vd25lcjtcbiAgICBpZiAoZCAhPSBudWxsKSB7XG4gICAgICBpZiAoZC5yZWYgIT09IHZvaWQgMCAmJiAoRyA9IGQucmVmLCBIID0gbmUuY3VycmVudCksIGQua2V5ICE9PSB2b2lkIDAgJiYgKFcgPSBcIlwiICsgZC5rZXkpLCBhLnR5cGUgJiYgYS50eXBlLmRlZmF1bHRQcm9wcykgdmFyIHogPSBhLnR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgZm9yIChZIGluIGQpIEouY2FsbChkLCBZKSAmJiAhZmUuaGFzT3duUHJvcGVydHkoWSkgJiYgKElbWV0gPSBkW1ldID09PSB2b2lkIDAgJiYgeiAhPT0gdm9pZCAwID8geltZXSA6IGRbWV0pO1xuICAgIH1cbiAgICB2YXIgWSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChZID09PSAxKSBJLmNoaWxkcmVuID0gRDtcbiAgICBlbHNlIGlmICgxIDwgWSkge1xuICAgICAgeiA9IEFycmF5KFkpO1xuICAgICAgZm9yICh2YXIgYWUgPSAwOyBhZSA8IFk7IGFlKyspIHpbYWVdID0gYXJndW1lbnRzW2FlICsgMl07XG4gICAgICBJLmNoaWxkcmVuID0gejtcbiAgICB9XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IHMsIHR5cGU6IGEudHlwZSwga2V5OiBXLCByZWY6IEcsIHByb3BzOiBJLCBfb3duZXI6IEggfTtcbiAgfSwgQS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhID0geyAkJHR5cGVvZjogYiwgX2N1cnJlbnRWYWx1ZTogYSwgX2N1cnJlbnRWYWx1ZTI6IGEsIF90aHJlYWRDb3VudDogMCwgUHJvdmlkZXI6IG51bGwsIENvbnN1bWVyOiBudWxsLCBfZGVmYXVsdFZhbHVlOiBudWxsLCBfZ2xvYmFsTmFtZTogbnVsbCB9LCBhLlByb3ZpZGVyID0geyAkJHR5cGVvZjogaiwgX2NvbnRleHQ6IGEgfSwgYS5Db25zdW1lciA9IGE7XG4gIH0sIEEuY3JlYXRlRWxlbWVudCA9IHZlLCBBLmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIGQgPSB2ZS5iaW5kKG51bGwsIGEpO1xuICAgIHJldHVybiBkLnR5cGUgPSBhLCBkO1xuICB9LCBBLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgfSwgQS5mb3J3YXJkUmVmID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiB4LCByZW5kZXI6IGEgfTtcbiAgfSwgQS5pc1ZhbGlkRWxlbWVudCA9IENlLCBBLmxhenkgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IG0sIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBhIH0sIF9pbml0OiBoZSB9O1xuICB9LCBBLm1lbW8gPSBmdW5jdGlvbihhLCBkKSB7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IHksIHR5cGU6IGEsIGNvbXBhcmU6IGQgPT09IHZvaWQgMCA/IG51bGwgOiBkIH07XG4gIH0sIEEuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBkID0geWUudHJhbnNpdGlvbjtcbiAgICB5ZS50cmFuc2l0aW9uID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGEoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgeWUudHJhbnNpdGlvbiA9IGQ7XG4gICAgfVxuICB9LCBBLnVuc3RhYmxlX2FjdCA9IGJlLCBBLnVzZUNhbGxiYWNrID0gZnVuY3Rpb24oYSwgZCkge1xuICAgIHJldHVybiBrLmN1cnJlbnQudXNlQ2FsbGJhY2soYSwgZCk7XG4gIH0sIEEudXNlQ29udGV4dCA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gay5jdXJyZW50LnVzZUNvbnRleHQoYSk7XG4gIH0sIEEudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICB9LCBBLnVzZURlZmVycmVkVmFsdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGsuY3VycmVudC51c2VEZWZlcnJlZFZhbHVlKGEpO1xuICB9LCBBLnVzZUVmZmVjdCA9IGZ1bmN0aW9uKGEsIGQpIHtcbiAgICByZXR1cm4gay5jdXJyZW50LnVzZUVmZmVjdChhLCBkKTtcbiAgfSwgQS51c2VJZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrLmN1cnJlbnQudXNlSWQoKTtcbiAgfSwgQS51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24oYSwgZCwgRCkge1xuICAgIHJldHVybiBrLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShhLCBkLCBEKTtcbiAgfSwgQS51c2VJbnNlcnRpb25FZmZlY3QgPSBmdW5jdGlvbihhLCBkKSB7XG4gICAgcmV0dXJuIGsuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoYSwgZCk7XG4gIH0sIEEudXNlTGF5b3V0RWZmZWN0ID0gZnVuY3Rpb24oYSwgZCkge1xuICAgIHJldHVybiBrLmN1cnJlbnQudXNlTGF5b3V0RWZmZWN0KGEsIGQpO1xuICB9LCBBLnVzZU1lbW8gPSBmdW5jdGlvbihhLCBkKSB7XG4gICAgcmV0dXJuIGsuY3VycmVudC51c2VNZW1vKGEsIGQpO1xuICB9LCBBLnVzZVJlZHVjZXIgPSBmdW5jdGlvbihhLCBkLCBEKSB7XG4gICAgcmV0dXJuIGsuY3VycmVudC51c2VSZWR1Y2VyKGEsIGQsIEQpO1xuICB9LCBBLnVzZVJlZiA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gay5jdXJyZW50LnVzZVJlZihhKTtcbiAgfSwgQS51c2VTdGF0ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gay5jdXJyZW50LnVzZVN0YXRlKGEpO1xuICB9LCBBLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZnVuY3Rpb24oYSwgZCwgRCkge1xuICAgIHJldHVybiBrLmN1cnJlbnQudXNlU3luY0V4dGVybmFsU3RvcmUoYSwgZCwgRCk7XG4gIH0sIEEudXNlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrLmN1cnJlbnQudXNlVHJhbnNpdGlvbigpO1xuICB9LCBBLnZlcnNpb24gPSBcIjE4LjMuMVwiLCBBO1xufVxudmFyIFFlID0geyBleHBvcnRzOiB7fSB9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuUWUuZXhwb3J0cztcbnZhciBndDtcbmZ1bmN0aW9uIEd0KCkge1xuICByZXR1cm4gZ3QgfHwgKGd0ID0gMSwgZnVuY3Rpb24ocywgYykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPCBcInVcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PSBcImZ1bmN0aW9uXCIgJiYgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG4gICAgICB2YXIgaSA9IFwiMTguMy4xXCIsIGYgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgUiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIGogPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIGIgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIHggPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIHkgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgTiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIEIgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgUyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIFAgPSBTeW1ib2wuaXRlcmF0b3IsIE8gPSBcIkBAaXRlcmF0b3JcIjtcbiAgICAgIGZ1bmN0aW9uIGcoZSkge1xuICAgICAgICBpZiAoZSA9PT0gbnVsbCB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgciA9IFAgJiYgZVtQXSB8fCBlW09dO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gciA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgWCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICB9LCBLID0ge1xuICAgICAgICB0cmFuc2l0aW9uOiBudWxsXG4gICAgICB9LCBKID0ge1xuICAgICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLlxuICAgICAgICBpc0JhdGNoaW5nTGVnYWN5OiAhMSxcbiAgICAgICAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6ICExXG4gICAgICB9LCBuZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICB9LCBmZSA9IHt9LCB2ZSA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBnZShlKSB7XG4gICAgICAgIHZlID0gZTtcbiAgICAgIH1cbiAgICAgIGZlLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmUgPSBlO1xuICAgICAgfSwgZmUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbCwgZmUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IFwiXCI7XG4gICAgICAgIHZlICYmIChlICs9IHZlKTtcbiAgICAgICAgdmFyIHIgPSBmZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIHJldHVybiByICYmIChlICs9IHIoKSB8fCBcIlwiKSwgZTtcbiAgICAgIH07XG4gICAgICB2YXIgQ2UgPSAhMSwgQmUgPSAhMSwgU2UgPSAhMSwgY2UgPSAhMSwgZGUgPSAhMSwgc2UgPSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFgsXG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBLLFxuICAgICAgICBSZWFjdEN1cnJlbnRPd25lcjogbmVcbiAgICAgIH07XG4gICAgICBzZS5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gZmUsIHNlLlJlYWN0Q3VycmVudEFjdFF1ZXVlID0gSjtcbiAgICAgIGZ1bmN0aW9uIGhlKGUpIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KHIgPiAxID8gciAtIDEgOiAwKSwgbCA9IDE7IGwgPCByOyBsKyspXG4gICAgICAgICAgICBvW2wgLSAxXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgICAgICB5ZShcIndhcm5cIiwgZSwgbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGsoZSkge1xuICAgICAgICB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkociA+IDEgPyByIC0gMSA6IDApLCBsID0gMTsgbCA8IHI7IGwrKylcbiAgICAgICAgICAgIG9bbCAtIDFdID0gYXJndW1lbnRzW2xdO1xuICAgICAgICAgIHllKFwiZXJyb3JcIiwgZSwgbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHllKGUsIHIsIG8pIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsID0gc2UuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgdiA9IGwuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICAgIHYgIT09IFwiXCIgJiYgKHIgKz0gXCIlc1wiLCBvID0gby5jb25jYXQoW3ZdKSk7XG4gICAgICAgICAgdmFyIHcgPSBvLm1hcChmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKF8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHcudW5zaGlmdChcIldhcm5pbmc6IFwiICsgciksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbZV0sIGNvbnNvbGUsIHcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgT2UgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGJlKGUsIHIpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBvID0gZS5jb25zdHJ1Y3RvciwgbCA9IG8gJiYgKG8uZGlzcGxheU5hbWUgfHwgby5uYW1lKSB8fCBcIlJlYWN0Q2xhc3NcIiwgdiA9IGwgKyBcIi5cIiArIHI7XG4gICAgICAgICAgaWYgKE9lW3ZdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGsoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiBJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LlwiLCByLCBsKSwgT2Vbdl0gPSAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGEgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAgICAgICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAgICAgICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAgICAgICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgICAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uKGUsIHIsIG8pIHtcbiAgICAgICAgICBiZShlLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgICAgICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAgICAgICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgICAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbihlLCByLCBvLCBsKSB7XG4gICAgICAgICAgYmUoZSwgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICAgICAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAgICAgICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgICAgICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uKGUsIHIsIG8sIGwpIHtcbiAgICAgICAgICBiZShlLCBcInNldFN0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICB9LCBkID0gT2JqZWN0LmFzc2lnbiwgRCA9IHt9O1xuICAgICAgT2JqZWN0LmZyZWV6ZShEKTtcbiAgICAgIGZ1bmN0aW9uIEkoZSwgciwgbykge1xuICAgICAgICB0aGlzLnByb3BzID0gZSwgdGhpcy5jb250ZXh0ID0gciwgdGhpcy5yZWZzID0gRCwgdGhpcy51cGRhdGVyID0gbyB8fCBhO1xuICAgICAgfVxuICAgICAgSS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9LCBJLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKGUsIHIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgJiYgdHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiICYmIGUgIT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIik7XG4gICAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgZSwgciwgXCJzZXRTdGF0ZVwiKTtcbiAgICAgIH0sIEkucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGUsIFwiZm9yY2VVcGRhdGVcIik7XG4gICAgICB9O1xuICAgICAge1xuICAgICAgICB2YXIgVyA9IHtcbiAgICAgICAgICBpc01vdW50ZWQ6IFtcImlzTW91bnRlZFwiLCBcIkluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLlwiXSxcbiAgICAgICAgICByZXBsYWNlU3RhdGU6IFtcInJlcGxhY2VTdGF0ZVwiLCBcIlJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuXCJdXG4gICAgICAgIH0sIEcgPSBmdW5jdGlvbihlLCByKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEkucHJvdG90eXBlLCBlLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBoZShcIiVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzXCIsIHJbMF0sIHJbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBIIGluIFcpXG4gICAgICAgICAgVy5oYXNPd25Qcm9wZXJ0eShIKSAmJiBHKEgsIFdbSF0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geigpIHtcbiAgICAgIH1cbiAgICAgIHoucHJvdG90eXBlID0gSS5wcm90b3R5cGU7XG4gICAgICBmdW5jdGlvbiBZKGUsIHIsIG8pIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IGUsIHRoaXMuY29udGV4dCA9IHIsIHRoaXMucmVmcyA9IEQsIHRoaXMudXBkYXRlciA9IG8gfHwgYTtcbiAgICAgIH1cbiAgICAgIHZhciBhZSA9IFkucHJvdG90eXBlID0gbmV3IHooKTtcbiAgICAgIGFlLmNvbnN0cnVjdG9yID0gWSwgZChhZSwgSS5wcm90b3R5cGUpLCBhZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9ICEwO1xuICAgICAgZnVuY3Rpb24geHIoKSB7XG4gICAgICAgIHZhciBlID0ge1xuICAgICAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5zZWFsKGUpLCBlO1xuICAgICAgfVxuICAgICAgdmFyIFplID0gQXJyYXkuaXNBcnJheTtcbiAgICAgIGZ1bmN0aW9uIEllKGUpIHtcbiAgICAgICAgcmV0dXJuIFplKGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3IoZSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHIgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIG8gPSByICYmIGVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBlLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTWUoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBqZShlKSwgITE7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gamUoZSkge1xuICAgICAgICByZXR1cm4gXCJcIiArIGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUZShlKSB7XG4gICAgICAgIGlmIChNZShlKSlcbiAgICAgICAgICByZXR1cm4gayhcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCBfcihlKSksIGplKGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXIoZSwgciwgbykge1xuICAgICAgICB2YXIgbCA9IGUuZGlzcGxheU5hbWU7XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB2YXIgdiA9IHIuZGlzcGxheU5hbWUgfHwgci5uYW1lIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiB2ICE9PSBcIlwiID8gbyArIFwiKFwiICsgdiArIFwiKVwiIDogbztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFBlKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtZShlKSB7XG4gICAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgZS50YWcgPT0gXCJudW1iZXJcIiAmJiBrKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgIGNhc2UgajpcbiAgICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSB4OlxuICAgICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgICAgY2FzZSBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgICBjYXNlIE46XG4gICAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgeTpcbiAgICAgICAgICAgICAgdmFyIHIgPSBlO1xuICAgICAgICAgICAgICByZXR1cm4gUGUocikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgICAgY2FzZSBoOlxuICAgICAgICAgICAgICB2YXIgbyA9IGU7XG4gICAgICAgICAgICAgIHJldHVybiBQZShvLl9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgICBjYXNlIG06XG4gICAgICAgICAgICAgIHJldHVybiBlcihlLCBlLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICB2YXIgbCA9IGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIGwgIT09IG51bGwgPyBsIDogbWUoZS50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICAgIGNhc2UgQjoge1xuICAgICAgICAgICAgICB2YXIgdiA9IGUsIHcgPSB2Ll9wYXlsb2FkLCBfID0gdi5faW5pdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUoXyh3KSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBOZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIExlID0ge1xuICAgICAgICBrZXk6ICEwLFxuICAgICAgICByZWY6ICEwLFxuICAgICAgICBfX3NlbGY6ICEwLFxuICAgICAgICBfX3NvdXJjZTogITBcbiAgICAgIH0sIHJyLCB0ciwgV2U7XG4gICAgICBXZSA9IHt9O1xuICAgICAgZnVuY3Rpb24gemUoZSkge1xuICAgICAgICBpZiAoTmUuY2FsbChlLCBcInJlZlwiKSkge1xuICAgICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcInJlZlwiKS5nZXQ7XG4gICAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZWYgIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFJlKGUpIHtcbiAgICAgICAgaWYgKE5lLmNhbGwoZSwgXCJrZXlcIikpIHtcbiAgICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICAgIGlmIChyICYmIHIuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUua2V5ICE9PSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBqcihlLCByKSB7XG4gICAgICAgIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcnIgfHwgKHJyID0gITAsIGsoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIG8uaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IG8sXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5yKGUsIHIpIHtcbiAgICAgICAgdmFyIG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ciB8fCAodHIgPSAhMCwgayhcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgby5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogbyxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXIoZSkge1xuICAgICAgICBpZiAodHlwZW9mIGUucmVmID09IFwic3RyaW5nXCIgJiYgbmUuY3VycmVudCAmJiBlLl9fc2VsZiAmJiBuZS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gZS5fX3NlbGYpIHtcbiAgICAgICAgICB2YXIgciA9IG1lKG5lLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgV2Vbcl0gfHwgKGsoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCByLCBlLnJlZiksIFdlW3JdID0gITApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgJGUgPSBmdW5jdGlvbihlLCByLCBvLCBsLCB2LCB3LCBfKSB7XG4gICAgICAgIHZhciBUID0ge1xuICAgICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAgICQkdHlwZW9mOiBmLFxuICAgICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICB0eXBlOiBlLFxuICAgICAgICAgIGtleTogcixcbiAgICAgICAgICByZWY6IG8sXG4gICAgICAgICAgcHJvcHM6IF8sXG4gICAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICBfb3duZXI6IHdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFQuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShULl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFQsIFwiX3NlbGZcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICAgIHZhbHVlOiBsXG4gICAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoVCwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShULnByb3BzKSwgT2JqZWN0LmZyZWV6ZShUKSksIFQ7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gUnIoZSwgciwgbykge1xuICAgICAgICB2YXIgbCwgdiA9IHt9LCB3ID0gbnVsbCwgXyA9IG51bGwsIFQgPSBudWxsLCBNID0gbnVsbDtcbiAgICAgICAgaWYgKHIgIT0gbnVsbCkge1xuICAgICAgICAgIHplKHIpICYmIChfID0gci5yZWYsIGFyKHIpKSwgUmUocikgJiYgKFRlKHIua2V5KSwgdyA9IFwiXCIgKyByLmtleSksIFQgPSByLl9fc2VsZiA9PT0gdm9pZCAwID8gbnVsbCA6IHIuX19zZWxmLCBNID0gci5fX3NvdXJjZSA9PT0gdm9pZCAwID8gbnVsbCA6IHIuX19zb3VyY2U7XG4gICAgICAgICAgZm9yIChsIGluIHIpXG4gICAgICAgICAgICBOZS5jYWxsKHIsIGwpICYmICFMZS5oYXNPd25Qcm9wZXJ0eShsKSAmJiAodltsXSA9IHJbbF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICAgIGlmIChxID09PSAxKVxuICAgICAgICAgIHYuY2hpbGRyZW4gPSBvO1xuICAgICAgICBlbHNlIGlmIChxID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIFEgPSBBcnJheShxKSwgWiA9IDA7IFogPCBxOyBaKyspXG4gICAgICAgICAgICBRW1pdID0gYXJndW1lbnRzW1ogKyAyXTtcbiAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoUSksIHYuY2hpbGRyZW4gPSBRO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlICYmIGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIHJlID0gZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChsIGluIHJlKVxuICAgICAgICAgICAgdltsXSA9PT0gdm9pZCAwICYmICh2W2xdID0gcmVbbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3IHx8IF8pIHtcbiAgICAgICAgICB2YXIgb2UgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBcIlVua25vd25cIiA6IGU7XG4gICAgICAgICAgdyAmJiBqcih2LCBvZSksIF8gJiYgbnIodiwgb2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkZShlLCB3LCBfLCBULCBNLCBuZS5jdXJyZW50LCB2KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEVyKGUsIHIpIHtcbiAgICAgICAgdmFyIG8gPSAkZShlLnR5cGUsIHIsIGUucmVmLCBlLl9zZWxmLCBlLl9zb3VyY2UsIGUuX293bmVyLCBlLnByb3BzKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBrcihlLCByLCBvKSB7XG4gICAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlICsgXCIuXCIpO1xuICAgICAgICB2YXIgbCwgdiA9IGQoe30sIGUucHJvcHMpLCB3ID0gZS5rZXksIF8gPSBlLnJlZiwgVCA9IGUuX3NlbGYsIE0gPSBlLl9zb3VyY2UsIHEgPSBlLl9vd25lcjtcbiAgICAgICAgaWYgKHIgIT0gbnVsbCkge1xuICAgICAgICAgIHplKHIpICYmIChfID0gci5yZWYsIHEgPSBuZS5jdXJyZW50KSwgUmUocikgJiYgKFRlKHIua2V5KSwgdyA9IFwiXCIgKyByLmtleSk7XG4gICAgICAgICAgdmFyIFE7XG4gICAgICAgICAgZS50eXBlICYmIGUudHlwZS5kZWZhdWx0UHJvcHMgJiYgKFEgPSBlLnR5cGUuZGVmYXVsdFByb3BzKTtcbiAgICAgICAgICBmb3IgKGwgaW4gcilcbiAgICAgICAgICAgIE5lLmNhbGwociwgbCkgJiYgIUxlLmhhc093blByb3BlcnR5KGwpICYmIChyW2xdID09PSB2b2lkIDAgJiYgUSAhPT0gdm9pZCAwID8gdltsXSA9IFFbbF0gOiB2W2xdID0gcltsXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFogPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgaWYgKFogPT09IDEpXG4gICAgICAgICAgdi5jaGlsZHJlbiA9IG87XG4gICAgICAgIGVsc2UgaWYgKFogPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgcmUgPSBBcnJheShaKSwgb2UgPSAwOyBvZSA8IFo7IG9lKyspXG4gICAgICAgICAgICByZVtvZV0gPSBhcmd1bWVudHNbb2UgKyAyXTtcbiAgICAgICAgICB2LmNoaWxkcmVuID0gcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRlKGUudHlwZSwgdywgXywgVCwgTSwgcSwgdik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBFZShlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgZS4kJHR5cGVvZiA9PT0gZjtcbiAgICAgIH1cbiAgICAgIHZhciBvciA9IFwiLlwiLCB3ciA9IFwiOlwiO1xuICAgICAgZnVuY3Rpb24gQ3IoZSkge1xuICAgICAgICB2YXIgciA9IC9bPTpdL2csIG8gPSB7XG4gICAgICAgICAgXCI9XCI6IFwiPTBcIixcbiAgICAgICAgICBcIjpcIjogXCI9MlwiXG4gICAgICAgIH0sIGwgPSBlLnJlcGxhY2UociwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBvW3ZdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiJFwiICsgbDtcbiAgICAgIH1cbiAgICAgIHZhciBWZSA9ICExLCBzciA9IC9cXC8rL2c7XG4gICAgICBmdW5jdGlvbiB4ZShlKSB7XG4gICAgICAgIHJldHVybiBlLnJlcGxhY2Uoc3IsIFwiJCYvXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gQWUoZSwgcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIGUua2V5ICE9IG51bGwgPyAoVGUoZS5rZXkpLCBDcihcIlwiICsgZS5rZXkpKSA6IHIudG9TdHJpbmcoMzYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24ga2UoZSwgciwgbywgbCwgdikge1xuICAgICAgICB2YXIgdyA9IHR5cGVvZiBlO1xuICAgICAgICAodyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3ID09PSBcImJvb2xlYW5cIikgJiYgKGUgPSBudWxsKTtcbiAgICAgICAgdmFyIF8gPSAhMTtcbiAgICAgICAgaWYgKGUgPT09IG51bGwpXG4gICAgICAgICAgXyA9ICEwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3dpdGNoICh3KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgIF8gPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgICAgICBfID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChfKSB7XG4gICAgICAgICAgdmFyIFQgPSBlLCBNID0gdihUKSwgcSA9IGwgPT09IFwiXCIgPyBvciArIEFlKFQsIDApIDogbDtcbiAgICAgICAgICBpZiAoSWUoTSkpIHtcbiAgICAgICAgICAgIHZhciBRID0gXCJcIjtcbiAgICAgICAgICAgIHEgIT0gbnVsbCAmJiAoUSA9IHhlKHEpICsgXCIvXCIpLCBrZShNLCByLCBRLCBcIlwiLCBmdW5jdGlvbihIdCkge1xuICAgICAgICAgICAgICByZXR1cm4gSHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgTSAhPSBudWxsICYmIChFZShNKSAmJiAoTS5rZXkgJiYgKCFUIHx8IFQua2V5ICE9PSBNLmtleSkgJiYgVGUoTS5rZXkpLCBNID0gRXIoXG4gICAgICAgICAgICBNLFxuICAgICAgICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICAgICAgbyArIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgICAgKE0ua2V5ICYmICghVCB8fCBULmtleSAhPT0gTS5rZXkpID8gKFxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgICAgICB4ZShcIlwiICsgTS5rZXkpICsgXCIvXCJcbiAgICAgICAgICAgICkgOiBcIlwiKSArIHFcbiAgICAgICAgICApKSwgci5wdXNoKE0pKTtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgWiwgcmUsIG9lID0gMCwgbGUgPSBsID09PSBcIlwiID8gb3IgOiBsICsgd3I7XG4gICAgICAgIGlmIChJZShlKSlcbiAgICAgICAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgZS5sZW5ndGg7IGdyKyspXG4gICAgICAgICAgICBaID0gZVtncl0sIHJlID0gbGUgKyBBZShaLCBnciksIG9lICs9IGtlKFosIHIsIG8sIHJlLCB2KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIFlyID0gZyhlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIFlyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHZ0ID0gZTtcbiAgICAgICAgICAgIFlyID09PSB2dC5lbnRyaWVzICYmIChWZSB8fCBoZShcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIiksIFZlID0gITApO1xuICAgICAgICAgICAgZm9yICh2YXIgQnQgPSBZci5jYWxsKHZ0KSwgaHQsIHp0ID0gMDsgIShodCA9IEJ0Lm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBaID0gaHQudmFsdWUsIHJlID0gbGUgKyBBZShaLCB6dCsrKSwgb2UgKz0ga2UoWiwgciwgbywgcmUsIHYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHl0ID0gU3RyaW5nKGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArICh5dCA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhlKS5qb2luKFwiLCBcIikgKyBcIn1cIiA6IHl0KSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9lO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRGUoZSwgciwgbykge1xuICAgICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB2YXIgbCA9IFtdLCB2ID0gMDtcbiAgICAgICAgcmV0dXJuIGtlKGUsIGwsIFwiXCIsIFwiXCIsIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICByZXR1cm4gci5jYWxsKG8sIHcsIHYrKyk7XG4gICAgICAgIH0pLCBsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gU3IoZSkge1xuICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgIHJldHVybiBEZShlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByKys7XG4gICAgICAgIH0pLCByO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXIoZSwgciwgbykge1xuICAgICAgICBEZShlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIG8pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gT3IoZSkge1xuICAgICAgICByZXR1cm4gRGUoZSwgZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KSB8fCBbXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxyKGUpIHtcbiAgICAgICAgaWYgKCFFZShlKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3IoZSkge1xuICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAkJHR5cGVvZjogeSxcbiAgICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgICAgICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgICAgICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgICAgICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgICAgICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgICAgICAgX2N1cnJlbnRWYWx1ZTogZSxcbiAgICAgICAgICBfY3VycmVudFZhbHVlMjogZSxcbiAgICAgICAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAgICAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICAgICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgICAgLy8gQWRkIHRoZXNlIHRvIHVzZSBzYW1lIGhpZGRlbiBjbGFzcyBpbiBWTSBhcyBTZXJ2ZXJDb250ZXh0XG4gICAgICAgICAgX2RlZmF1bHRWYWx1ZTogbnVsbCxcbiAgICAgICAgICBfZ2xvYmFsTmFtZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByLlByb3ZpZGVyID0ge1xuICAgICAgICAgICQkdHlwZW9mOiBoLFxuICAgICAgICAgIF9jb250ZXh0OiByXG4gICAgICAgIH07XG4gICAgICAgIHZhciBvID0gITEsIGwgPSAhMSwgdiA9ICExO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogeSxcbiAgICAgICAgICAgIF9jb250ZXh0OiByXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3LCB7XG4gICAgICAgICAgICBQcm92aWRlcjoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsIHx8IChsID0gITAsIGsoXCJSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkP1wiKSksIHIuUHJvdmlkZXI7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIHIuUHJvdmlkZXIgPSBfO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLl9jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIHIuX2N1cnJlbnRWYWx1ZSA9IF87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLl9jdXJyZW50VmFsdWUyO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgICAgICByLl9jdXJyZW50VmFsdWUyID0gXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLl90aHJlYWRDb3VudDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICAgICAgci5fdGhyZWFkQ291bnQgPSBfO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbyB8fCAobyA9ICEwLCBrKFwiUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD9cIikpLCByLkNvbnN1bWVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICAgICAgdiB8fCAoaGUoXCJTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiBZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBfKSwgdiA9ICEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCByLkNvbnN1bWVyID0gdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci5fY3VycmVudFJlbmRlcmVyID0gbnVsbCwgci5fY3VycmVudFJlbmRlcmVyMiA9IG51bGwsIHI7XG4gICAgICB9XG4gICAgICB2YXIgRmUgPSAtMSwgSGUgPSAwLCBxZSA9IDEsIHVyID0gMjtcbiAgICAgIGZ1bmN0aW9uIFRyKGUpIHtcbiAgICAgICAgaWYgKGUuX3N0YXR1cyA9PT0gRmUpIHtcbiAgICAgICAgICB2YXIgciA9IGUuX3Jlc3VsdCwgbyA9IHIoKTtcbiAgICAgICAgICBpZiAoby50aGVuKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgIGlmIChlLl9zdGF0dXMgPT09IEhlIHx8IGUuX3N0YXR1cyA9PT0gRmUpIHtcbiAgICAgICAgICAgICAgdmFyIF8gPSBlO1xuICAgICAgICAgICAgICBfLl9zdGF0dXMgPSBxZSwgXy5fcmVzdWx0ID0gdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbih3KSB7XG4gICAgICAgICAgICBpZiAoZS5fc3RhdHVzID09PSBIZSB8fCBlLl9zdGF0dXMgPT09IEZlKSB7XG4gICAgICAgICAgICAgIHZhciBfID0gZTtcbiAgICAgICAgICAgICAgXy5fc3RhdHVzID0gdXIsIF8uX3Jlc3VsdCA9IHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGUuX3N0YXR1cyA9PT0gRmUpIHtcbiAgICAgICAgICAgIHZhciBsID0gZTtcbiAgICAgICAgICAgIGwuX3N0YXR1cyA9IEhlLCBsLl9yZXN1bHQgPSBvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5fc3RhdHVzID09PSBxZSkge1xuICAgICAgICAgIHZhciB2ID0gZS5fcmVzdWx0O1xuICAgICAgICAgIHJldHVybiB2ID09PSB2b2lkIDAgJiYgayhgbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcblxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXG5cbkRpZCB5b3UgYWNjaWRlbnRhbGx5IHB1dCBjdXJseSBicmFjZXMgYXJvdW5kIHRoZSBpbXBvcnQ/YCwgdiksIFwiZGVmYXVsdFwiIGluIHYgfHwgayhgbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcblxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpYCwgdiksIHYuZGVmYXVsdDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhyb3cgZS5fcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUHIoZSkge1xuICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgICAgICAgX3N0YXR1czogRmUsXG4gICAgICAgICAgX3Jlc3VsdDogZVxuICAgICAgICB9LCBvID0ge1xuICAgICAgICAgICQkdHlwZW9mOiBCLFxuICAgICAgICAgIF9wYXlsb2FkOiByLFxuICAgICAgICAgIF9pbml0OiBUclxuICAgICAgICB9O1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGwsIHY7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobywge1xuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odykge1xuICAgICAgICAgICAgICAgIGsoXCJSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvIGEgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC5cIiksIGwgPSB3LCBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BUeXBlczoge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgICAgICBrKFwiUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byBhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50IGlzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuXCIpLCB2ID0gdywgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwicHJvcFR5cGVzXCIsIHtcbiAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE5yKGUpIHtcbiAgICAgICAgZSAhPSBudWxsICYmIGUuJCR0eXBlb2YgPT09IEwgPyBrKFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKS5cIikgOiB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgPyBrKFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLlwiLCBlID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgZSkgOiBlLmxlbmd0aCAhPT0gMCAmJiBlLmxlbmd0aCAhPT0gMiAmJiBrKFwiZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlc1wiLCBlLmxlbmd0aCA9PT0gMSA/IFwiRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyP1wiIDogXCJBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuXCIpLCBlICE9IG51bGwgJiYgKGUuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgZS5wcm9wVHlwZXMgIT0gbnVsbCkgJiYgayhcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50P1wiKTtcbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgJCR0eXBlb2Y6IG0sXG4gICAgICAgICAgcmVuZGVyOiBlXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbztcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgbyA9IGwsICFlLm5hbWUgJiYgIWUuZGlzcGxheU5hbWUgJiYgKGUuZGlzcGxheU5hbWUgPSBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIHZhciBmcjtcbiAgICAgIGZyID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgICBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgcmV0dXJuICEhKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiIHx8IGUgPT09IGogfHwgZSA9PT0geCB8fCBkZSB8fCBlID09PSBiIHx8IGUgPT09IEUgfHwgZSA9PT0gTiB8fCBjZSB8fCBlID09PSBTIHx8IENlIHx8IEJlIHx8IFNlIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAoZS4kJHR5cGVvZiA9PT0gQiB8fCBlLiQkdHlwZW9mID09PSBMIHx8IGUuJCR0eXBlb2YgPT09IGggfHwgZS4kJHR5cGVvZiA9PT0geSB8fCBlLiQkdHlwZW9mID09PSBtIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgICAgLy8gd2l0aC5cbiAgICAgICAgZS4kJHR5cGVvZiA9PT0gZnIgfHwgZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KGUsIHIpIHtcbiAgICAgICAgdChlKSB8fCBrKFwibWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzXCIsIGUgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBlKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgJCR0eXBlb2Y6IEwsXG4gICAgICAgICAgdHlwZTogZSxcbiAgICAgICAgICBjb21wYXJlOiByID09PSB2b2lkIDAgPyBudWxsIDogclxuICAgICAgICB9O1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIGwgPSB2LCAhZS5uYW1lICYmICFlLmRpc3BsYXlOYW1lICYmIChlLmRpc3BsYXlOYW1lID0gdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICB2YXIgZSA9IFguY3VycmVudDtcbiAgICAgICAgcmV0dXJuIGUgPT09IG51bGwgJiYgayhgSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5gKSwgZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEMoZSkge1xuICAgICAgICB2YXIgciA9IHAoKTtcbiAgICAgICAgaWYgKGUuX2NvbnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBvID0gZS5fY29udGV4dDtcbiAgICAgICAgICBvLkNvbnN1bWVyID09PSBlID8gayhcIkNhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/XCIpIDogby5Qcm92aWRlciA9PT0gZSAmJiBrKFwiQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudXNlQ29udGV4dChlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFYoZSkge1xuICAgICAgICB2YXIgciA9IHAoKTtcbiAgICAgICAgcmV0dXJuIHIudXNlU3RhdGUoZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBVKGUsIHIsIG8pIHtcbiAgICAgICAgdmFyIGwgPSBwKCk7XG4gICAgICAgIHJldHVybiBsLnVzZVJlZHVjZXIoZSwgciwgbyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBGKGUpIHtcbiAgICAgICAgdmFyIHIgPSBwKCk7XG4gICAgICAgIHJldHVybiByLnVzZVJlZihlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uICQoZSwgcikge1xuICAgICAgICB2YXIgbyA9IHAoKTtcbiAgICAgICAgcmV0dXJuIG8udXNlRWZmZWN0KGUsIHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaWUoZSwgcikge1xuICAgICAgICB2YXIgbyA9IHAoKTtcbiAgICAgICAgcmV0dXJuIG8udXNlSW5zZXJ0aW9uRWZmZWN0KGUsIHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZWUoZSwgcikge1xuICAgICAgICB2YXIgbyA9IHAoKTtcbiAgICAgICAgcmV0dXJuIG8udXNlTGF5b3V0RWZmZWN0KGUsIHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdGUoZSwgcikge1xuICAgICAgICB2YXIgbyA9IHAoKTtcbiAgICAgICAgcmV0dXJuIG8udXNlQ2FsbGJhY2soZSwgcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZShlLCByKSB7XG4gICAgICAgIHZhciBvID0gcCgpO1xuICAgICAgICByZXR1cm4gby51c2VNZW1vKGUsIHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gd2UoZSwgciwgbykge1xuICAgICAgICB2YXIgbCA9IHAoKTtcbiAgICAgICAgcmV0dXJuIGwudXNlSW1wZXJhdGl2ZUhhbmRsZShlLCByLCBvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9lKGUsIHIpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBvID0gcCgpO1xuICAgICAgICAgIHJldHVybiBvLnVzZURlYnVnVmFsdWUoZSwgcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVlKCkge1xuICAgICAgICB2YXIgZSA9IHAoKTtcbiAgICAgICAgcmV0dXJuIGUudXNlVHJhbnNpdGlvbigpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gS2UoZSkge1xuICAgICAgICB2YXIgciA9IHAoKTtcbiAgICAgICAgcmV0dXJuIHIudXNlRGVmZXJyZWRWYWx1ZShlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uICRyKCkge1xuICAgICAgICB2YXIgZSA9IHAoKTtcbiAgICAgICAgcmV0dXJuIGUudXNlSWQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEFyKGUsIHIsIG8pIHtcbiAgICAgICAgdmFyIGwgPSBwKCk7XG4gICAgICAgIHJldHVybiBsLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGUsIHIsIG8pO1xuICAgICAgfVxuICAgICAgdmFyIEdlID0gMCwgcXIsIEtyLCBHciwgWHIsIEpyLCBRciwgWnI7XG4gICAgICBmdW5jdGlvbiBldCgpIHtcbiAgICAgIH1cbiAgICAgIGV0Ll9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgICAgZnVuY3Rpb24gd3QoKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoR2UgPT09IDApIHtcbiAgICAgICAgICAgIHFyID0gY29uc29sZS5sb2csIEtyID0gY29uc29sZS5pbmZvLCBHciA9IGNvbnNvbGUud2FybiwgWHIgPSBjb25zb2xlLmVycm9yLCBKciA9IGNvbnNvbGUuZ3JvdXAsIFFyID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgWnIgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICB2YWx1ZTogZXQsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgICAgaW5mbzogZSxcbiAgICAgICAgICAgICAgbG9nOiBlLFxuICAgICAgICAgICAgICB3YXJuOiBlLFxuICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgZ3JvdXA6IGUsXG4gICAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBlLFxuICAgICAgICAgICAgICBncm91cEVuZDogZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEdlKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEN0KCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKEdlLS0sIEdlID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgICAgbG9nOiBkKHt9LCBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHFyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBpbmZvOiBkKHt9LCBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEtyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB3YXJuOiBkKHt9LCBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEdyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBlcnJvcjogZCh7fSwgZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBYclxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZ3JvdXA6IGQoe30sIGUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogSnJcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBkKHt9LCBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFFyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBncm91cEVuZDogZCh7fSwgZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBaclxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEdlIDwgMCAmJiBrKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIERyID0gc2UuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgRnI7XG4gICAgICBmdW5jdGlvbiBkcihlLCByLCBvKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoRnIgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgICAgICAgIHZhciBsID0gdi5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgICAgRnIgPSBsICYmIGxbMV0gfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYFxuYCArIEZyICsgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIElyID0gITEsIHByO1xuICAgICAge1xuICAgICAgICB2YXIgU3QgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgICBwciA9IG5ldyBTdCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcnQoZSwgcikge1xuICAgICAgICBpZiAoIWUgfHwgSXIpXG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbyA9IHByLmdldChlKTtcbiAgICAgICAgICBpZiAobyAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGw7XG4gICAgICAgIElyID0gITA7XG4gICAgICAgIHZhciB2ID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdyA9IERyLmN1cnJlbnQsIERyLmN1cnJlbnQgPSBudWxsLCB3dCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICB2YXIgXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoXywgW10pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChsZSkge1xuICAgICAgICAgICAgICAgIGwgPSBsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChlLCBbXSwgXyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF8uY2FsbCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChsZSkge1xuICAgICAgICAgICAgICAgIGwgPSBsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlLmNhbGwoXy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAobGUpIHtcbiAgICAgICAgICAgICAgbCA9IGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAobGUpIHtcbiAgICAgICAgICBpZiAobGUgJiYgbCAmJiB0eXBlb2YgbGUuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZm9yICh2YXIgVCA9IGxlLnN0YWNrLnNwbGl0KGBcbmApLCBNID0gbC5zdGFjay5zcGxpdChgXG5gKSwgcSA9IFQubGVuZ3RoIC0gMSwgUSA9IE0ubGVuZ3RoIC0gMTsgcSA+PSAxICYmIFEgPj0gMCAmJiBUW3FdICE9PSBNW1FdOyApXG4gICAgICAgICAgICAgIFEtLTtcbiAgICAgICAgICAgIGZvciAoOyBxID49IDEgJiYgUSA+PSAwOyBxLS0sIFEtLSlcbiAgICAgICAgICAgICAgaWYgKFRbcV0gIT09IE1bUV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocSAhPT0gMSB8fCBRICE9PSAxKVxuICAgICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHEtLSwgUS0tLCBRIDwgMCB8fCBUW3FdICE9PSBNW1FdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIFogPSBgXG5gICsgVFtxXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lICYmIFouaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoWiA9IFoucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGUuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIHByLnNldChlLCBaKSwgWjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHEgPj0gMSAmJiBRID49IDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIElyID0gITEsIERyLmN1cnJlbnQgPSB3LCBDdCgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gZSA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIDogXCJcIiwgb2UgPSByZSA/IGRyKHJlKSA6IFwiXCI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgcHIuc2V0KGUsIG9lKSwgb2U7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBPdChlLCByLCBvKSB7XG4gICAgICAgIHJldHVybiBydChlLCAhMSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUdChlKSB7XG4gICAgICAgIHZhciByID0gZS5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiAhIShyICYmIHIuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB2cihlLCByLCBvKSB7XG4gICAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHJ0KGUsIFR0KGUpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIGRyKGUpO1xuICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgICBjYXNlIEU6XG4gICAgICAgICAgICByZXR1cm4gZHIoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgICBjYXNlIE46XG4gICAgICAgICAgICByZXR1cm4gZHIoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIG06XG4gICAgICAgICAgICAgIHJldHVybiBPdChlLnJlbmRlcik7XG4gICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgIHJldHVybiB2cihlLnR5cGUsIHIsIG8pO1xuICAgICAgICAgICAgY2FzZSBCOiB7XG4gICAgICAgICAgICAgIHZhciBsID0gZSwgdiA9IGwuX3BheWxvYWQsIHcgPSBsLl9pbml0O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2cih3KHYpLCByLCBvKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIHR0ID0ge30sIG50ID0gc2UuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICAgIGZ1bmN0aW9uIGhyKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICB2YXIgciA9IGUuX293bmVyLCBvID0gdnIoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgICBudC5zZXRFeHRyYVN0YWNrRnJhbWUobyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG50LnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFB0KGUsIHIsIG8sIGwsIHYpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciB3ID0gRnVuY3Rpb24uY2FsbC5iaW5kKE5lKTtcbiAgICAgICAgICBmb3IgKHZhciBfIGluIGUpXG4gICAgICAgICAgICBpZiAodyhlLCBfKSkge1xuICAgICAgICAgICAgICB2YXIgVCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVbX10gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgTSA9IEVycm9yKChsIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBvICsgXCIgdHlwZSBgXCIgKyBfICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBlW19dICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICAgIHRocm93IE0ubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBNO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBUID0gZVtfXShyLCBfLCBsLCBvLCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChxKSB7XG4gICAgICAgICAgICAgICAgVCA9IHE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVCAmJiAhKFQgaW5zdGFuY2VvZiBFcnJvcikgJiYgKGhyKHYpLCBrKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBsIHx8IFwiUmVhY3QgY2xhc3NcIiwgbywgXywgdHlwZW9mIFQpLCBocihudWxsKSksIFQgaW5zdGFuY2VvZiBFcnJvciAmJiAhKFQubWVzc2FnZSBpbiB0dCkgJiYgKHR0W1QubWVzc2FnZV0gPSAhMCwgaHIodiksIGsoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgbywgVC5tZXNzYWdlKSwgaHIobnVsbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBZZShlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgbyA9IHZyKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgICAgZ2Uobyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGdlKG51bGwpO1xuICAgICAgfVxuICAgICAgdmFyIE1yO1xuICAgICAgTXIgPSAhMTtcbiAgICAgIGZ1bmN0aW9uIGF0KCkge1xuICAgICAgICBpZiAobmUuY3VycmVudCkge1xuICAgICAgICAgIHZhciBlID0gbWUobmUuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBlICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTnQoZSkge1xuICAgICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCBvID0gZS5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgciArIFwiOlwiICsgbyArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gJHQoZSkge1xuICAgICAgICByZXR1cm4gZSAhPSBudWxsID8gTnQoZS5fX3NvdXJjZSkgOiBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIG90ID0ge307XG4gICAgICBmdW5jdGlvbiBBdChlKSB7XG4gICAgICAgIHZhciByID0gYXQoKTtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmFyIG8gPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lO1xuICAgICAgICAgIG8gJiYgKHIgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyBvICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0KGUsIHIpIHtcbiAgICAgICAgaWYgKCEoIWUuX3N0b3JlIHx8IGUuX3N0b3JlLnZhbGlkYXRlZCB8fCBlLmtleSAhPSBudWxsKSkge1xuICAgICAgICAgIGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICAgIHZhciBvID0gQXQocik7XG4gICAgICAgICAgaWYgKCFvdFtvXSkge1xuICAgICAgICAgICAgb3Rbb10gPSAhMDtcbiAgICAgICAgICAgIHZhciBsID0gXCJcIjtcbiAgICAgICAgICAgIGUgJiYgZS5fb3duZXIgJiYgZS5fb3duZXIgIT09IG5lLmN1cnJlbnQgJiYgKGwgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIG1lKGUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBZZShlKSwgaygnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgbywgbCksIFllKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXQoZSwgcikge1xuICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChJZShlKSlcbiAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgICB2YXIgbCA9IGVbb107XG4gICAgICAgICAgICAgIEVlKGwpICYmIHN0KGwsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKEVlKGUpKVxuICAgICAgICAgICAgZS5fc3RvcmUgJiYgKGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgICBlbHNlIGlmIChlKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGcoZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiICYmIHYgIT09IGUuZW50cmllcylcbiAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IHYuY2FsbChlKSwgXzsgIShfID0gdy5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgICBFZShfLnZhbHVlKSAmJiBzdChfLnZhbHVlLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGx0KGUpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciByID0gZS50eXBlO1xuICAgICAgICAgIGlmIChyID09IG51bGwgfHwgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB2YXIgbztcbiAgICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbyA9IHIucHJvcFR5cGVzO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgKHIuJCR0eXBlb2YgPT09IG0gfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICAgIHIuJCR0eXBlb2YgPT09IEwpKVxuICAgICAgICAgICAgbyA9IHIucHJvcFR5cGVzO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgdmFyIGwgPSBtZShyKTtcbiAgICAgICAgICAgIFB0KG8sIGUucHJvcHMsIFwicHJvcFwiLCBsLCBlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHIuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIU1yKSB7XG4gICAgICAgICAgICBNciA9ICEwO1xuICAgICAgICAgICAgdmFyIHYgPSBtZShyKTtcbiAgICAgICAgICAgIGsoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgdiB8fCBcIlVua25vd25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGVvZiByLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIXIuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIGsoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRHQoZSkge1xuICAgICAgICB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IE9iamVjdC5rZXlzKGUucHJvcHMpLCBvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgIHZhciBsID0gcltvXTtcbiAgICAgICAgICAgIGlmIChsICE9PSBcImNoaWxkcmVuXCIgJiYgbCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICBZZShlKSwgayhcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIGwpLCBZZShudWxsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGUucmVmICE9PSBudWxsICYmIChZZShlKSwgayhcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBZZShudWxsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGN0KGUsIHIsIG8pIHtcbiAgICAgICAgdmFyIGwgPSB0KGUpO1xuICAgICAgICBpZiAoIWwpIHtcbiAgICAgICAgICB2YXIgdiA9IFwiXCI7XG4gICAgICAgICAgKGUgPT09IHZvaWQgMCB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZSkubGVuZ3RoID09PSAwKSAmJiAodiArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciB3ID0gJHQocik7XG4gICAgICAgICAgdyA/IHYgKz0gdyA6IHYgKz0gYXQoKTtcbiAgICAgICAgICB2YXIgXztcbiAgICAgICAgICBlID09PSBudWxsID8gXyA9IFwibnVsbFwiIDogSWUoZSkgPyBfID0gXCJhcnJheVwiIDogZSAhPT0gdm9pZCAwICYmIGUuJCR0eXBlb2YgPT09IGYgPyAoXyA9IFwiPFwiICsgKG1lKGUudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgdiA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogXyA9IHR5cGVvZiBlLCBrKFwiUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBfLCB2KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVCA9IFJyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChUID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFQ7XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIGZvciAodmFyIE0gPSAyOyBNIDwgYXJndW1lbnRzLmxlbmd0aDsgTSsrKVxuICAgICAgICAgICAgaXQoYXJndW1lbnRzW01dLCBlKTtcbiAgICAgICAgcmV0dXJuIGUgPT09IGogPyBEdChUKSA6IGx0KFQpLCBUO1xuICAgICAgfVxuICAgICAgdmFyIHV0ID0gITE7XG4gICAgICBmdW5jdGlvbiBGdChlKSB7XG4gICAgICAgIHZhciByID0gY3QuYmluZChudWxsLCBlKTtcbiAgICAgICAgcmV0dXJuIHIudHlwZSA9IGUsIHV0IHx8ICh1dCA9ICEwLCBoZShcIlJlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYIG9yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC5cIikpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhlKFwiRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS5cIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwge1xuICAgICAgICAgICAgICB2YWx1ZTogZVxuICAgICAgICAgICAgfSksIGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEl0KGUsIHIsIG8pIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IGtyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHYgPSAyOyB2IDwgYXJndW1lbnRzLmxlbmd0aDsgdisrKVxuICAgICAgICAgIGl0KGFyZ3VtZW50c1t2XSwgbC50eXBlKTtcbiAgICAgICAgcmV0dXJuIGx0KGwpLCBsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTXQoZSwgcikge1xuICAgICAgICB2YXIgbyA9IEsudHJhbnNpdGlvbjtcbiAgICAgICAgSy50cmFuc2l0aW9uID0ge307XG4gICAgICAgIHZhciBsID0gSy50cmFuc2l0aW9uO1xuICAgICAgICBLLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoSy50cmFuc2l0aW9uID0gbywgbyA9PT0gbnVsbCAmJiBsLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGwuX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcbiAgICAgICAgICAgIHYgPiAxMCAmJiBoZShcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiKSwgbC5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZ0ID0gITEsIHlyID0gbnVsbDtcbiAgICAgIGZ1bmN0aW9uIEx0KGUpIHtcbiAgICAgICAgaWYgKHlyID09PSBudWxsKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgciA9IChcInJlcXVpcmVcIiArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDAsIDcpLCBvID0gcyAmJiBzW3JdO1xuICAgICAgICAgICAgeXIgPSBvLmNhbGwocywgXCJ0aW1lcnNcIikuc2V0SW1tZWRpYXRlO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgeXIgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIGZ0ID09PSAhMSAmJiAoZnQgPSAhMCwgdHlwZW9mIE1lc3NhZ2VDaGFubmVsID4gXCJ1XCIgJiYgayhcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sIHNvIGVucXVldWluZyB0YXNrcyB2aWEgYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLikgd2lsbCBmYWlsLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzIGlmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLlwiKSk7XG4gICAgICAgICAgICAgIHZhciB3ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgIHcucG9ydDEub25tZXNzYWdlID0gdiwgdy5wb3J0Mi5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB5cihlKTtcbiAgICAgIH1cbiAgICAgIHZhciBVZSA9IDAsIGR0ID0gITE7XG4gICAgICBmdW5jdGlvbiBwdChlKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgciA9IFVlO1xuICAgICAgICAgIFVlKyssIEouY3VycmVudCA9PT0gbnVsbCAmJiAoSi5jdXJyZW50ID0gW10pO1xuICAgICAgICAgIHZhciBvID0gSi5pc0JhdGNoaW5nTGVnYWN5LCBsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoSi5pc0JhdGNoaW5nTGVnYWN5ID0gITAsIGwgPSBlKCksICFvICYmIEouZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBKLmN1cnJlbnQ7XG4gICAgICAgICAgICAgIHYgIT09IG51bGwgJiYgKEouZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSAhMSwgVnIodikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICAgICAgICB0aHJvdyBtcihyKSwgcmU7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIEouaXNCYXRjaGluZ0xlZ2FjeSA9IG87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsICE9PSBudWxsICYmIHR5cGVvZiBsID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGwudGhlbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciB3ID0gbCwgXyA9ICExLCBUID0ge1xuICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbihyZSwgb2UpIHtcbiAgICAgICAgICAgICAgICBfID0gITAsIHcudGhlbihmdW5jdGlvbihsZSkge1xuICAgICAgICAgICAgICAgICAgbXIociksIFVlID09PSAwID8gTHIobGUsIHJlLCBvZSkgOiByZShsZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24obGUpIHtcbiAgICAgICAgICAgICAgICAgIG1yKHIpLCBvZShsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gIWR0ICYmIHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF8gfHwgKGR0ID0gITAsIGsoXCJZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuIFRoaXMgY291bGQgbGVhZCB0byB1bmV4cGVjdGVkIHRlc3RpbmcgYmVoYXZpb3VyLCBpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgc2NvcGVzLiBZb3Ugc2hvdWxkIC0gYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLik7XCIpKTtcbiAgICAgICAgICAgIH0pLCBUO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgTSA9IGw7XG4gICAgICAgICAgICBpZiAobXIociksIFVlID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBxID0gSi5jdXJyZW50O1xuICAgICAgICAgICAgICBxICE9PSBudWxsICYmIChWcihxKSwgSi5jdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgIHZhciBRID0ge1xuICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKHJlLCBvZSkge1xuICAgICAgICAgICAgICAgICAgSi5jdXJyZW50ID09PSBudWxsID8gKEouY3VycmVudCA9IFtdLCBMcihNLCByZSwgb2UpKSA6IHJlKE0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgWiA9IHtcbiAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbihyZSwgb2UpIHtcbiAgICAgICAgICAgICAgICAgIHJlKE0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIFo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtcihlKSB7XG4gICAgICAgIGUgIT09IFVlIC0gMSAmJiBrKFwiWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBCZSBzdXJlIHRvIGF3YWl0IHByZXZpb3VzIGFjdCgpIGNhbGxzIGJlZm9yZSBtYWtpbmcgYSBuZXcgb25lLiBcIiksIFVlID0gZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIExyKGUsIHIsIG8pIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsID0gSi5jdXJyZW50O1xuICAgICAgICAgIGlmIChsICE9PSBudWxsKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgVnIobCksIEx0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGwubGVuZ3RoID09PSAwID8gKEouY3VycmVudCA9IG51bGwsIHIoZSkpIDogTHIoZSwgciwgbyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAodikge1xuICAgICAgICAgICAgICBvKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBXciA9ICExO1xuICAgICAgZnVuY3Rpb24gVnIoZSkge1xuICAgICAgICBpZiAoIVdyKSB7XG4gICAgICAgICAgV3IgPSAhMDtcbiAgICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICB2YXIgbyA9IGVbcl07XG4gICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgbyA9IG8oITApO1xuICAgICAgICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgfSBjYXRjaCAobCkge1xuICAgICAgICAgICAgdGhyb3cgZSA9IGUuc2xpY2UociArIDEpLCBsO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBXciA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIFd0ID0gY3QsIFZ0ID0gSXQsIFl0ID0gRnQsIFV0ID0ge1xuICAgICAgICBtYXA6IERlLFxuICAgICAgICBmb3JFYWNoOiBpcixcbiAgICAgICAgY291bnQ6IFNyLFxuICAgICAgICB0b0FycmF5OiBPcixcbiAgICAgICAgb25seTogbHJcbiAgICAgIH07XG4gICAgICBjLkNoaWxkcmVuID0gVXQsIGMuQ29tcG9uZW50ID0gSSwgYy5GcmFnbWVudCA9IGosIGMuUHJvZmlsZXIgPSB4LCBjLlB1cmVDb21wb25lbnQgPSBZLCBjLlN0cmljdE1vZGUgPSBiLCBjLlN1c3BlbnNlID0gRSwgYy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHNlLCBjLmFjdCA9IHB0LCBjLmNsb25lRWxlbWVudCA9IFZ0LCBjLmNyZWF0ZUNvbnRleHQgPSBjciwgYy5jcmVhdGVFbGVtZW50ID0gV3QsIGMuY3JlYXRlRmFjdG9yeSA9IFl0LCBjLmNyZWF0ZVJlZiA9IHhyLCBjLmZvcndhcmRSZWYgPSBOciwgYy5pc1ZhbGlkRWxlbWVudCA9IEVlLCBjLmxhenkgPSBQciwgYy5tZW1vID0gdSwgYy5zdGFydFRyYW5zaXRpb24gPSBNdCwgYy51bnN0YWJsZV9hY3QgPSBwdCwgYy51c2VDYWxsYmFjayA9IHRlLCBjLnVzZUNvbnRleHQgPSBDLCBjLnVzZURlYnVnVmFsdWUgPSBfZSwgYy51c2VEZWZlcnJlZFZhbHVlID0gS2UsIGMudXNlRWZmZWN0ID0gJCwgYy51c2VJZCA9ICRyLCBjLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB3ZSwgYy51c2VJbnNlcnRpb25FZmZlY3QgPSBpZSwgYy51c2VMYXlvdXRFZmZlY3QgPSBlZSwgYy51c2VNZW1vID0gcGUsIGMudXNlUmVkdWNlciA9IFUsIGMudXNlUmVmID0gRiwgYy51c2VTdGF0ZSA9IFYsIGMudXNlU3luY0V4dGVybmFsU3RvcmUgPSBBciwgYy51c2VUcmFuc2l0aW9uID0gdWUsIGMudmVyc2lvbiA9IGksIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPCBcInVcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09IFwiZnVuY3Rpb25cIiAmJiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuICAgIH0oKTtcbiAgfShRZSwgUWUuZXhwb3J0cykpLCBRZS5leHBvcnRzO1xufVxudmFyIGJ0O1xuZnVuY3Rpb24gSHIoKSB7XG4gIHJldHVybiBidCB8fCAoYnQgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBici5leHBvcnRzID0gS3QoKSA6IGJyLmV4cG9ydHMgPSBHdCgpKSwgYnIuZXhwb3J0cztcbn1cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciB4dDtcbmZ1bmN0aW9uIFh0KCkge1xuICBpZiAoeHQpIHJldHVybiBYZTtcbiAgeHQgPSAxO1xuICB2YXIgcyA9IEhyKCksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgZiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIFIgPSBzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBqID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gYih4LCBoLCB5KSB7XG4gICAgdmFyIG0sIEUgPSB7fSwgTiA9IG51bGwsIEwgPSBudWxsO1xuICAgIHkgIT09IHZvaWQgMCAmJiAoTiA9IFwiXCIgKyB5KSwgaC5rZXkgIT09IHZvaWQgMCAmJiAoTiA9IFwiXCIgKyBoLmtleSksIGgucmVmICE9PSB2b2lkIDAgJiYgKEwgPSBoLnJlZik7XG4gICAgZm9yIChtIGluIGgpIGYuY2FsbChoLCBtKSAmJiAhai5oYXNPd25Qcm9wZXJ0eShtKSAmJiAoRVttXSA9IGhbbV0pO1xuICAgIGlmICh4ICYmIHguZGVmYXVsdFByb3BzKSBmb3IgKG0gaW4gaCA9IHguZGVmYXVsdFByb3BzLCBoKSBFW21dID09PSB2b2lkIDAgJiYgKEVbbV0gPSBoW21dKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogYywgdHlwZTogeCwga2V5OiBOLCByZWY6IEwsIHByb3BzOiBFLCBfb3duZXI6IFIuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBYZS5GcmFnbWVudCA9IGksIFhlLmpzeCA9IGIsIFhlLmpzeHMgPSBiLCBYZTtcbn1cbnZhciBKZSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIF90O1xuZnVuY3Rpb24gSnQoKSB7XG4gIHJldHVybiBfdCB8fCAoX3QgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHMgPSBIcigpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIGkgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBmID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBSID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBqID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBiID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCB4ID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIHkgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBOID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIEwgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBCID0gU3ltYm9sLml0ZXJhdG9yLCBTID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gUCh0KSB7XG4gICAgICBpZiAodCA9PT0gbnVsbCB8fCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB1ID0gQiAmJiB0W0JdIHx8IHRbU107XG4gICAgICByZXR1cm4gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSA6IG51bGw7XG4gICAgfVxuICAgIHZhciBPID0gcy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBnKHQpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkodSA+IDEgPyB1IC0gMSA6IDApLCBDID0gMTsgQyA8IHU7IEMrKylcbiAgICAgICAgICBwW0MgLSAxXSA9IGFyZ3VtZW50c1tDXTtcbiAgICAgICAgWChcImVycm9yXCIsIHQsIHApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBYKHQsIHUsIHApIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEMgPSBPLlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIFYgPSBDLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgViAhPT0gXCJcIiAmJiAodSArPSBcIiVzXCIsIHAgPSBwLmNvbmNhdChbVl0pKTtcbiAgICAgICAgdmFyIFUgPSBwLm1hcChmdW5jdGlvbihGKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhGKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFUudW5zaGlmdChcIldhcm5pbmc6IFwiICsgdSksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbdF0sIGNvbnNvbGUsIFUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSyA9ICExLCBKID0gITEsIG5lID0gITEsIGZlID0gITEsIHZlID0gITEsIGdlO1xuICAgIGdlID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gQ2UodCkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiIHx8IHQgPT09IGYgfHwgdCA9PT0gaiB8fCB2ZSB8fCB0ID09PSBSIHx8IHQgPT09IHkgfHwgdCA9PT0gbSB8fCBmZSB8fCB0ID09PSBMIHx8IEsgfHwgSiB8fCBuZSB8fCB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgKHQuJCR0eXBlb2YgPT09IE4gfHwgdC4kJHR5cGVvZiA9PT0gRSB8fCB0LiQkdHlwZW9mID09PSBiIHx8IHQuJCR0eXBlb2YgPT09IHggfHwgdC4kJHR5cGVvZiA9PT0gaCB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgIC8vIHdpdGguXG4gICAgICB0LiQkdHlwZW9mID09PSBnZSB8fCB0LmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmUodCwgdSwgcCkge1xuICAgICAgdmFyIEMgPSB0LmRpc3BsYXlOYW1lO1xuICAgICAgaWYgKEMpXG4gICAgICAgIHJldHVybiBDO1xuICAgICAgdmFyIFYgPSB1LmRpc3BsYXlOYW1lIHx8IHUubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIFYgIT09IFwiXCIgPyBwICsgXCIoXCIgKyBWICsgXCIpXCIgOiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZSh0KSB7XG4gICAgICByZXR1cm4gdC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2UodCkge1xuICAgICAgaWYgKHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIHQudGFnID09IFwibnVtYmVyXCIgJiYgZyhcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiB0LmRpc3BsYXlOYW1lIHx8IHQubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgajpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBtOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0ID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAodC4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgeDpcbiAgICAgICAgICAgIHZhciB1ID0gdDtcbiAgICAgICAgICAgIHJldHVybiBTZSh1KSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgdmFyIHAgPSB0O1xuICAgICAgICAgICAgcmV0dXJuIFNlKHAuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgICByZXR1cm4gQmUodCwgdC5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIEU6XG4gICAgICAgICAgICB2YXIgQyA9IHQuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBDICE9PSBudWxsID8gQyA6IGNlKHQudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBOOiB7XG4gICAgICAgICAgICB2YXIgViA9IHQsIFUgPSBWLl9wYXlsb2FkLCBGID0gVi5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBjZShGKFUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZGUgPSBPYmplY3QuYXNzaWduLCBzZSA9IDAsIGhlLCBrLCB5ZSwgT2UsIGJlLCBhLCBkO1xuICAgIGZ1bmN0aW9uIEQoKSB7XG4gICAgfVxuICAgIEQuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gSSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHNlID09PSAwKSB7XG4gICAgICAgICAgaGUgPSBjb25zb2xlLmxvZywgayA9IGNvbnNvbGUuaW5mbywgeWUgPSBjb25zb2xlLndhcm4sIE9lID0gY29uc29sZS5lcnJvciwgYmUgPSBjb25zb2xlLmdyb3VwLCBhID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogRCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogdCxcbiAgICAgICAgICAgIGxvZzogdCxcbiAgICAgICAgICAgIHdhcm46IHQsXG4gICAgICAgICAgICBlcnJvcjogdCxcbiAgICAgICAgICAgIGdyb3VwOiB0LFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHQsXG4gICAgICAgICAgICBncm91cEVuZDogdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChzZS0tLCBzZSA9PT0gMCkge1xuICAgICAgICAgIHZhciB0ID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IGRlKHt9LCB0LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBoZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBkZSh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZToga1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBkZSh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogeWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IGRlKHt9LCB0LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBPZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogZGUoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGJlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBkZSh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogYVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogZGUoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2UgPCAwICYmIGcoXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRyA9IE8uUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgSDtcbiAgICBmdW5jdGlvbiB6KHQsIHUsIHApIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEggPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChWKSB7XG4gICAgICAgICAgICB2YXIgQyA9IFYuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBIID0gQyAmJiBDWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIEggKyB0O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgWSA9ICExLCBhZTtcbiAgICB7XG4gICAgICB2YXIgeHIgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgYWUgPSBuZXcgeHIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWmUodCwgdSkge1xuICAgICAgaWYgKCF0IHx8IFkpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgcCA9IGFlLmdldCh0KTtcbiAgICAgICAgaWYgKHAgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHZhciBDO1xuICAgICAgWSA9ICEwO1xuICAgICAgdmFyIFYgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIFU7XG4gICAgICBVID0gRy5jdXJyZW50LCBHLmN1cnJlbnQgPSBudWxsLCBJKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh1ZSkge1xuICAgICAgICAgICAgICBDID0gdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdCh0LCBbXSwgRik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEYuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAodWUpIHtcbiAgICAgICAgICAgICAgQyA9IHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5jYWxsKEYucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAodWUpIHtcbiAgICAgICAgICAgIEMgPSB1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh1ZSkge1xuICAgICAgICBpZiAodWUgJiYgQyAmJiB0eXBlb2YgdWUuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyICQgPSB1ZS5zdGFjay5zcGxpdChgXG5gKSwgaWUgPSBDLnN0YWNrLnNwbGl0KGBcbmApLCBlZSA9ICQubGVuZ3RoIC0gMSwgdGUgPSBpZS5sZW5ndGggLSAxOyBlZSA+PSAxICYmIHRlID49IDAgJiYgJFtlZV0gIT09IGllW3RlXTsgKVxuICAgICAgICAgICAgdGUtLTtcbiAgICAgICAgICBmb3IgKDsgZWUgPj0gMSAmJiB0ZSA+PSAwOyBlZS0tLCB0ZS0tKVxuICAgICAgICAgICAgaWYgKCRbZWVdICE9PSBpZVt0ZV0pIHtcbiAgICAgICAgICAgICAgaWYgKGVlICE9PSAxIHx8IHRlICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoZWUtLSwgdGUtLSwgdGUgPCAwIHx8ICRbZWVdICE9PSBpZVt0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gYFxuYCArICRbZWVdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmRpc3BsYXlOYW1lICYmIHBlLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKHBlID0gcGUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIHQuZGlzcGxheU5hbWUpKSwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIGFlLnNldCh0LCBwZSksIHBlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChlZSA+PSAxICYmIHRlID49IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgWSA9ICExLCBHLmN1cnJlbnQgPSBVLCBXKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gVjtcbiAgICAgIH1cbiAgICAgIHZhciB3ZSA9IHQgPyB0LmRpc3BsYXlOYW1lIHx8IHQubmFtZSA6IFwiXCIsIF9lID0gd2UgPyB6KHdlKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIGFlLnNldCh0LCBfZSksIF9lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJZSh0LCB1LCBwKSB7XG4gICAgICByZXR1cm4gWmUodCwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcih0KSB7XG4gICAgICB2YXIgdSA9IHQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKHUgJiYgdS5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWUodCwgdSwgcCkge1xuICAgICAgaWYgKHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gWmUodCwgX3IodCkpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB6KHQpO1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgeTpcbiAgICAgICAgICByZXR1cm4geihcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIG06XG4gICAgICAgICAgcmV0dXJuIHooXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoICh0LiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBoOlxuICAgICAgICAgICAgcmV0dXJuIEllKHQucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIEU6XG4gICAgICAgICAgICByZXR1cm4gTWUodC50eXBlLCB1LCBwKTtcbiAgICAgICAgICBjYXNlIE46IHtcbiAgICAgICAgICAgIHZhciBDID0gdCwgViA9IEMuX3BheWxvYWQsIFUgPSBDLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1lKFUoViksIHUsIHApO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIGplID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgVGUgPSB7fSwgZXIgPSBPLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gUGUodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0Ll9vd25lciwgcCA9IE1lKHQudHlwZSwgdC5fc291cmNlLCB1ID8gdS50eXBlIDogbnVsbCk7XG4gICAgICAgIGVyLnNldEV4dHJhU3RhY2tGcmFtZShwKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBlci5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lKHQsIHUsIHAsIEMsIFYpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFUgPSBGdW5jdGlvbi5jYWxsLmJpbmQoamUpO1xuICAgICAgICBmb3IgKHZhciBGIGluIHQpXG4gICAgICAgICAgaWYgKFUodCwgRikpIHtcbiAgICAgICAgICAgIHZhciAkID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0W0ZdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBpZSA9IEVycm9yKChDIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBwICsgXCIgdHlwZSBgXCIgKyBGICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiB0W0ZdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBpZS5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIGllO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICQgPSB0W0ZdKHUsIEYsIEMsIHAsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlZSkge1xuICAgICAgICAgICAgICAkID0gZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkICYmICEoJCBpbnN0YW5jZW9mIEVycm9yKSAmJiAoUGUoViksIGcoXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIEMgfHwgXCJSZWFjdCBjbGFzc1wiLCBwLCBGLCB0eXBlb2YgJCksIFBlKG51bGwpKSwgJCBpbnN0YW5jZW9mIEVycm9yICYmICEoJC5tZXNzYWdlIGluIFRlKSAmJiAoVGVbJC5tZXNzYWdlXSA9ICEwLCBQZShWKSwgZyhcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBwLCAkLm1lc3NhZ2UpLCBQZShudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgTmUgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIExlKHQpIHtcbiAgICAgIHJldHVybiBOZSh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnIodCkge1xuICAgICAge1xuICAgICAgICB2YXIgdSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgcCA9IHUgJiYgdFtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHQuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHIodCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFdlKHQpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdlKHQpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gemUodCkge1xuICAgICAgaWYgKHRyKHQpKVxuICAgICAgICByZXR1cm4gZyhcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCBycih0KSksIFdlKHQpO1xuICAgIH1cbiAgICB2YXIgUmUgPSBPLlJlYWN0Q3VycmVudE93bmVyLCBqciA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIG5yLCBhciwgJGU7XG4gICAgJGUgPSB7fTtcbiAgICBmdW5jdGlvbiBScih0KSB7XG4gICAgICBpZiAoamUuY2FsbCh0LCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAodSAmJiB1LmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFcih0KSB7XG4gICAgICBpZiAoamUuY2FsbCh0LCBcImtleVwiKSkge1xuICAgICAgICB2YXIgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAodSAmJiB1LmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrcih0LCB1KSB7XG4gICAgICBpZiAodHlwZW9mIHQucmVmID09IFwic3RyaW5nXCIgJiYgUmUuY3VycmVudCAmJiB1ICYmIFJlLmN1cnJlbnQuc3RhdGVOb2RlICE9PSB1KSB7XG4gICAgICAgIHZhciBwID0gY2UoUmUuY3VycmVudC50eXBlKTtcbiAgICAgICAgJGVbcF0gfHwgKGcoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjZShSZS5jdXJyZW50LnR5cGUpLCB0LnJlZiksICRlW3BdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBFZSh0LCB1KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbnIgfHwgKG5yID0gITAsIGcoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCB1KSk7XG4gICAgICAgIH07XG4gICAgICAgIHAuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IHAsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb3IodCwgdSkge1xuICAgICAge1xuICAgICAgICB2YXIgcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFyIHx8IChhciA9ICEwLCBnKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgdSkpO1xuICAgICAgICB9O1xuICAgICAgICBwLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiBwLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB3ciA9IGZ1bmN0aW9uKHQsIHUsIHAsIEMsIFYsIFUsIEYpIHtcbiAgICAgIHZhciAkID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IGMsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogdCxcbiAgICAgICAga2V5OiB1LFxuICAgICAgICByZWY6IHAsXG4gICAgICAgIHByb3BzOiBGLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IFVcbiAgICAgIH07XG4gICAgICByZXR1cm4gJC5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KCQuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IENcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoJCwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IFZcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKCQucHJvcHMpLCBPYmplY3QuZnJlZXplKCQpKSwgJDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENyKHQsIHUsIHAsIEMsIFYpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFUsIEYgPSB7fSwgJCA9IG51bGwsIGllID0gbnVsbDtcbiAgICAgICAgcCAhPT0gdm9pZCAwICYmICh6ZShwKSwgJCA9IFwiXCIgKyBwKSwgRXIodSkgJiYgKHplKHUua2V5KSwgJCA9IFwiXCIgKyB1LmtleSksIFJyKHUpICYmIChpZSA9IHUucmVmLCBrcih1LCBWKSk7XG4gICAgICAgIGZvciAoVSBpbiB1KVxuICAgICAgICAgIGplLmNhbGwodSwgVSkgJiYgIWpyLmhhc093blByb3BlcnR5KFUpICYmIChGW1VdID0gdVtVXSk7XG4gICAgICAgIGlmICh0ICYmIHQuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIGVlID0gdC5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChVIGluIGVlKVxuICAgICAgICAgICAgRltVXSA9PT0gdm9pZCAwICYmIChGW1VdID0gZWVbVV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkIHx8IGllKSB7XG4gICAgICAgICAgdmFyIHRlID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdC5kaXNwbGF5TmFtZSB8fCB0Lm5hbWUgfHwgXCJVbmtub3duXCIgOiB0O1xuICAgICAgICAgICQgJiYgRWUoRiwgdGUpLCBpZSAmJiBvcihGLCB0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyKHQsICQsIGllLCBWLCBDLCBSZS5jdXJyZW50LCBGKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFZlID0gTy5SZWFjdEN1cnJlbnRPd25lciwgc3IgPSBPLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24geGUodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0Ll9vd25lciwgcCA9IE1lKHQudHlwZSwgdC5fc291cmNlLCB1ID8gdS50eXBlIDogbnVsbCk7XG4gICAgICAgIHNyLnNldEV4dHJhU3RhY2tGcmFtZShwKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzci5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBBZTtcbiAgICBBZSA9ICExO1xuICAgIGZ1bmN0aW9uIGtlKHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgdC4kJHR5cGVvZiA9PT0gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gRGUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChWZS5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIHQgPSBjZShWZS5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIHQgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNyKHQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgaXIgPSB7fTtcbiAgICBmdW5jdGlvbiBPcih0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciB1ID0gRGUoKTtcbiAgICAgICAgaWYgKCF1KSB7XG4gICAgICAgICAgdmFyIHAgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuZGlzcGxheU5hbWUgfHwgdC5uYW1lO1xuICAgICAgICAgIHAgJiYgKHUgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyBwICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbHIodCwgdSkge1xuICAgICAge1xuICAgICAgICBpZiAoIXQuX3N0b3JlIHx8IHQuX3N0b3JlLnZhbGlkYXRlZCB8fCB0LmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdC5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciBwID0gT3IodSk7XG4gICAgICAgIGlmIChpcltwXSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlyW3BdID0gITA7XG4gICAgICAgIHZhciBDID0gXCJcIjtcbiAgICAgICAgdCAmJiB0Ll9vd25lciAmJiB0Ll9vd25lciAhPT0gVmUuY3VycmVudCAmJiAoQyA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY2UodC5fb3duZXIudHlwZSkgKyBcIi5cIiksIHhlKHQpLCBnKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBwLCBDKSwgeGUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyKHQsIHUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoTGUodCkpXG4gICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0Lmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgQyA9IHRbcF07XG4gICAgICAgICAgICBrZShDKSAmJiBscihDLCB1KTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtlKHQpKVxuICAgICAgICAgIHQuX3N0b3JlICYmICh0Ll9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgViA9IFAodCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBWID09IFwiZnVuY3Rpb25cIiAmJiBWICE9PSB0LmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBVID0gVi5jYWxsKHQpLCBGOyAhKEYgPSBVLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBrZShGLnZhbHVlKSAmJiBscihGLnZhbHVlLCB1KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBGZSh0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciB1ID0gdC50eXBlO1xuICAgICAgICBpZiAodSA9PSBudWxsIHx8IHR5cGVvZiB1ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgaWYgKHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBwID0gdS5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1ID09IFwib2JqZWN0XCIgJiYgKHUuJCR0eXBlb2YgPT09IGggfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgdS4kJHR5cGVvZiA9PT0gRSkpXG4gICAgICAgICAgcCA9IHUucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIHZhciBDID0gY2UodSk7XG4gICAgICAgICAgbWUocCwgdC5wcm9wcywgXCJwcm9wXCIsIEMsIHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHUuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIUFlKSB7XG4gICAgICAgICAgQWUgPSAhMDtcbiAgICAgICAgICB2YXIgViA9IGNlKHUpO1xuICAgICAgICAgIGcoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgViB8fCBcIlVua25vd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIHUuZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhdS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgZyhcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBIZSh0KSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHUgPSBPYmplY3Qua2V5cyh0LnByb3BzKSwgcCA9IDA7IHAgPCB1Lmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIEMgPSB1W3BdO1xuICAgICAgICAgIGlmIChDICE9PSBcImNoaWxkcmVuXCIgJiYgQyAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgeGUodCksIGcoXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLCBDKSwgeGUobnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdC5yZWYgIT09IG51bGwgJiYgKHhlKHQpLCBnKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIHhlKG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHFlID0ge307XG4gICAgZnVuY3Rpb24gdXIodCwgdSwgcCwgQywgViwgVSkge1xuICAgICAge1xuICAgICAgICB2YXIgRiA9IENlKHQpO1xuICAgICAgICBpZiAoIUYpIHtcbiAgICAgICAgICB2YXIgJCA9IFwiXCI7XG4gICAgICAgICAgKHQgPT09IHZvaWQgMCB8fCB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgT2JqZWN0LmtleXModCkubGVuZ3RoID09PSAwKSAmJiAoJCArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBpZSA9IFNyKCk7XG4gICAgICAgICAgaWUgPyAkICs9IGllIDogJCArPSBEZSgpO1xuICAgICAgICAgIHZhciBlZTtcbiAgICAgICAgICB0ID09PSBudWxsID8gZWUgPSBcIm51bGxcIiA6IExlKHQpID8gZWUgPSBcImFycmF5XCIgOiB0ICE9PSB2b2lkIDAgJiYgdC4kJHR5cGVvZiA9PT0gYyA/IChlZSA9IFwiPFwiICsgKGNlKHQudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgJCA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogZWUgPSB0eXBlb2YgdCwgZyhcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBlZSwgJCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlID0gQ3IodCwgdSwgcCwgViwgVSk7XG4gICAgICAgIGlmICh0ZSA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiB0ZTtcbiAgICAgICAgaWYgKEYpIHtcbiAgICAgICAgICB2YXIgcGUgPSB1LmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChwZSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKEMpXG4gICAgICAgICAgICAgIGlmIChMZShwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ZSA9IDA7IHdlIDwgcGUubGVuZ3RoOyB3ZSsrKVxuICAgICAgICAgICAgICAgICAgY3IocGVbd2VdLCB0KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUocGUpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBnKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY3IocGUsIHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqZS5jYWxsKHUsIFwia2V5XCIpKSB7XG4gICAgICAgICAgdmFyIF9lID0gY2UodCksIHVlID0gT2JqZWN0LmtleXModSkuZmlsdGVyKGZ1bmN0aW9uKEFyKSB7XG4gICAgICAgICAgICByZXR1cm4gQXIgIT09IFwia2V5XCI7XG4gICAgICAgICAgfSksIEtlID0gdWUubGVuZ3RoID4gMCA/IFwie2tleTogc29tZUtleSwgXCIgKyB1ZS5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgICAgaWYgKCFxZVtfZSArIEtlXSkge1xuICAgICAgICAgICAgdmFyICRyID0gdWUubGVuZ3RoID4gMCA/IFwie1wiICsgdWUuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiO1xuICAgICAgICAgICAgZyhgQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMgey4uLnByb3BzfSAvPlxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+YCwgS2UsIF9lLCAkciwgX2UpLCBxZVtfZSArIEtlXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCA9PT0gZiA/IEhlKHRlKSA6IEZlKHRlKSwgdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyKHQsIHUsIHApIHtcbiAgICAgIHJldHVybiB1cih0LCB1LCBwLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFByKHQsIHUsIHApIHtcbiAgICAgIHJldHVybiB1cih0LCB1LCBwLCAhMSk7XG4gICAgfVxuICAgIHZhciBOciA9IFByLCBmciA9IFRyO1xuICAgIEplLkZyYWdtZW50ID0gZiwgSmUuanN4ID0gTnIsIEplLmpzeHMgPSBmcjtcbiAgfSgpKSwgSmU7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBVci5leHBvcnRzID0gWHQoKSA6IFVyLmV4cG9ydHMgPSBKdCgpO1xudmFyIG4gPSBVci5leHBvcnRzO1xuY29uc3QgYW4gPSAoe1xuICB0aXRsZTogcyxcbiAgc3VtbWFyeTogYyxcbiAgdmFsdWU6IGksXG4gIHNpemU6IGYgPSAzNTAsXG4gIGJhY2tncm91bmQ6IFIgPSBcIiNmZmZcIixcbiAgZmdDb2xvcjogaiA9IFwiIzAwYmZmZlwiLFxuICBiZ0NvbG9yOiBiID0gXCIjY2NjXCIsXG4gIHRleHRDb2xvcjogeCA9IFwiIzAwMFwiLFxuICBsYWJlbENvbG9yOiBoID0gXCIjMDAwXCIsXG4gIGxhYmVsOiB5ID0gXCJcIixcbiAgcGFkZGluZzogbSA9IFwiMnJlbVwiLFxuICBwZXJjZW50YWdlVGV4dFNpemU6IEUgPSA0LFxuICB0aXRsZVRleHRTaXplOiBOID0gMS44LFxuICBzdW1tYXJ5VGV4dFNpemU6IEwgPSAxXG59KSA9PiB7XG4gIGNvbnN0IFMgPSBmIC8gMiAtIDMwLCBQID0gMiAqIE1hdGguUEkgKiBTLCBPID0gYCR7aSAvIDEwMCAqIFB9ICR7UH1gLCBnID0gZiArIDYwO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJkb3VnaG51dC1jaGFydC13cmFwcGVyXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBcIi0tYmFja2dyb3VuZC1jb2xvclwiOiBSLFxuICAgICAgICBcIi0tdGV4dC1jb2xvclwiOiB4LFxuICAgICAgICBcIi0tcGFkZGluZ1wiOiBtLFxuICAgICAgICBcIi0tdGl0bGUtc2l6ZVwiOiBgJHtOfXJlbWAsXG4gICAgICAgIFwiLS1zdW1tYXJ5LXNpemVcIjogYCR7TH1yZW1gLFxuICAgICAgICBcIi0tYmctY29sb3JcIjogYixcbiAgICAgICAgXCItLWZnLWNvbG9yXCI6IGosXG4gICAgICAgIFwiLS1sYWJlbC1jb2xvclwiOiBoLFxuICAgICAgICBcIi0tcGVyY2VudGFnZS1zaXplXCI6IGAke0V9cmVtYCxcbiAgICAgICAgXCItLXN0cm9rZS1kYXNoYXJyYXlcIjogT1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIHMgJiYgLyogQF9fUFVSRV9fICovIG4uanN4KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiY2hhcnQtdGl0bGVcIiwgY2hpbGRyZW46IHMgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZG91Z2hudXQtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4cyhcbiAgICAgICAgICAgIFwic3ZnXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzdmctY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgIHZpZXdCb3g6IGAwIDAgJHtnfSAke2d9YCxcbiAgICAgICAgICAgICAgd2lkdGg6IGYsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgICAgICAgXCJjaXJjbGVcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNpcmNsZS1iYWNrZ3JvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHI6IFMsXG4gICAgICAgICAgICAgICAgICAgIGN4OiBnIC8gMixcbiAgICAgICAgICAgICAgICAgICAgY3k6IGcgLyAyLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogNjBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgICAgICAgIFwiY2lyY2xlXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaXJjbGUtZm9yZWdyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICByOiBTLFxuICAgICAgICAgICAgICAgICAgICBjeDogZyAvIDIsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBnIC8gMixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDYwLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IE9cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwicGVyY2VudGFnZS10ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGcgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiBnIC8gMixcbiAgICAgICAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogeCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGAke2l9JWBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHkgJiYgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsYWJlbC10ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGcgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiBnIC8gMiArIDMwLFxuICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiBcIm1pZGRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBoLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogeVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgYyAmJiAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcImNoYXJ0LXN1bW1hcnlcIiwgY2hpbGRyZW46IGMgfSlcbiAgICAgICAgXSB9KVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn0sIG9uID0gKHtcbiAgZGF0YTogcyxcbiAgY29sb3JzOiBjID0gW1wicmdiYSgwLCAxMjMsIDI1NSwgMC43KVwiLCBcInJnYmEoMjU1LCAwLCAxMjMsIDAuNylcIl0sXG4gIGhlaWdodDogaSA9IDQwMCxcbiAgbGFiZWxDb2xvcjogZiA9IFwiIzAwMFwiLFxuICB3aWR0aDogUixcbiAgLy8gVGhlIHdpZHRoIGlzIG5vdyBwYXNzZWQgZGlyZWN0bHkgYXMgYSBwcm9wXG4gIGJhY2tncm91bmQ6IGogPSBcIiNmZmZcIixcbiAgZm9yZWdyb3VuZDogYiA9IFwiIzAwMFwiXG59KSA9PiB7XG4gIGNvbnN0IHggPSBzLmZsYXRNYXAoKFMpID0+IFtTLnNlcmllczEsIFMuc2VyaWVzMl0pLCBoID0gTWF0aC5taW4oLi4ueCksIHkgPSBNYXRoLm1heCguLi54KSwgbSA9IChTLCBQLCBPLCBnKSA9PiAoUyAtIFApIC8gKE8gLSBQKSAqIGcsIEUgPSAoUywgUCwgTykgPT4gUyAvIFAgKiBPLCBOID0gKFMsIFApID0+IHtcbiAgICBjb25zdCBPID0gRShQLCBzLmxlbmd0aCwgaSksIGcgPSBtKFMuc2VyaWVzMSwgaCwgeSwgUiksIFggPSBtKFMuc2VyaWVzMiwgaCwgeSwgUik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJnXCIsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgIHtcbiAgICAgICAgICB4MTogZyxcbiAgICAgICAgICB5MTogTyArIGkgLyBzLmxlbmd0aCAvIDIsXG4gICAgICAgICAgeDI6IFgsXG4gICAgICAgICAgeTI6IE8gKyBpIC8gcy5sZW5ndGggLyAyLFxuICAgICAgICAgIHN0cm9rZTogXCJ2YXIoLS1mb3JlZ3JvdW5kLWNvbG9yKVwiLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIlxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiY2lyY2xlXCIsIHsgY3g6IGcsIGN5OiBPICsgaSAvIHMubGVuZ3RoIC8gMiwgcjogNiwgZmlsbDogY1swXSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImNpcmNsZVwiLCB7IGN4OiBYLCBjeTogTyArIGkgLyBzLmxlbmd0aCAvIDIsIHI6IDYsIGZpbGw6IGNbMV0gfSlcbiAgICBdIH0sIGBkdW1iYmVsbC0ke1B9YCk7XG4gIH0sIEwgPSBzLm1hcCgoUywgUCkgPT4gLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgIFwidGV4dFwiLFxuICAgIHtcbiAgICAgIHg6IFwiLTEwXCIsXG4gICAgICB5OiBFKFAsIHMubGVuZ3RoLCBpKSArIGkgLyBzLmxlbmd0aCAvIDIgKyA1LFxuICAgICAgdGV4dEFuY2hvcjogXCJlbmRcIixcbiAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgIGZpbGw6IFwidmFyKC0tbGFiZWwtY29sb3IpXCIsXG4gICAgICBjaGlsZHJlbjogUy5mcnVpdFxuICAgIH0sXG4gICAgUFxuICApKSwgQiA9ICgpID0+IHtcbiAgICBjb25zdCBQID0gKHkgLSBoKSAvIDUsIE8gPSBbXTtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IDY7IGcrKykge1xuICAgICAgY29uc3QgWCA9IGggKyBnICogUCwgSyA9IG0oWCwgaCwgeSwgUik7XG4gICAgICBPLnB1c2goXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJnXCIsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDE6IEssXG4gICAgICAgICAgICAgIHkxOiBpLFxuICAgICAgICAgICAgICB4MjogSyxcbiAgICAgICAgICAgICAgeTI6IGkgKyA1LFxuICAgICAgICAgICAgICBzdHJva2U6IFwidmFyKC0tZm9yZWdyb3VuZC1jb2xvcilcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IEssXG4gICAgICAgICAgICAgIHk6IGkgKyAyMCxcbiAgICAgICAgICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICAgICAgICBmaWxsOiBcInZhcigtLWxhYmVsLWNvbG9yKVwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogWC50b0ZpeGVkKDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICBdIH0sIGB4LXRpY2stJHtnfWApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gTztcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJkdW1iYmVsbC1jaGFydC13cmFwcGVyXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBcIi0tYmFja2dyb3VuZC1jb2xvclwiOiBqLFxuICAgICAgICBcIi0tZm9yZWdyb3VuZC1jb2xvclwiOiBiLFxuICAgICAgICBcIi0tbGFiZWwtY29sb3JcIjogZixcbiAgICAgICAgXCItLWNoYXJ0LWhlaWdodFwiOiBgJHtpfXB4YFxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3ZnLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG4uanN4cyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIHZpZXdCb3g6IGAwIDAgJHtSfSAke2kgKyA1MH1gLFxuICAgICAgICAgIHN0eWxlOiB7IG92ZXJmbG93OiBcInZpc2libGVcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiIH0sXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHMubWFwKChTLCBQKSA9PiBOKFMsIFApKSxcbiAgICAgICAgICAgIEwsXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeDE6IFwiMFwiLFxuICAgICAgICAgICAgICAgIHkxOiBpLFxuICAgICAgICAgICAgICAgIHgyOiBSLFxuICAgICAgICAgICAgICAgIHkyOiBpLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJ2YXIoLS1mb3JlZ3JvdW5kLWNvbG9yKVwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgQigpXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICApIH0pXG4gICAgfVxuICApO1xufSwgc24gPSAoe1xuICB0aXRsZTogcyxcbiAgc3VtbWFyeTogYyxcbiAgYXJpYURlc2NyaXB0aW9uOiBpLFxuICBsYWJlbENvbG9yOiBmID0gXCIjMDAwXCIsXG4gIGJhY2tncm91bmQ6IFIgPSBcIiNmZmZcIixcbiAgZm9yZWdyb3VuZDogaiA9IFwiIzAwMFwiLFxuICBkYXRhOiBiXG59KSA9PiB7XG4gIGNvbnN0IHggPSBNYXRoLm1heCguLi5iLm1hcCgoaCkgPT4gaC52YWx1ZSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNvbXBhcmlzb24tZ3JhcGhcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiY2hhcnQtd3JhcHBlclwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgXCItLWJhY2tncm91bmQtY29sb3JcIjogUixcbiAgICAgICAgXCItLWZvcmVncm91bmQtY29sb3JcIjogalxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0aXRsZS1jb250YWluZXJcIixcbiAgICAgICAgICAgIHN0eWxlOiB7IFwiLS1mb3JlZ3JvdW5kLWNvbG9yXCI6IGogfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJncmFwaC10aXRsZVwiLCBjaGlsZHJlbjogcyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdyYXBoLWNvbnRhaW5lclwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjaGlsZHJlbjogYi5tYXAoKGgsIHkpID0+IHtcbiAgICAgICAgICBjb25zdCBtID0gTWF0aC5zcXJ0KGgudmFsdWUpIC8gTWF0aC5zcXJ0KHgpICogMTA7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaXJjbGUtd3JhcHBlclwiLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBgJHttfXJlbWAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHttfXJlbWAsXG4gICAgICAgICAgICAgICAgXCItLWNpcmNsZS1jb2xvclwiOiBoLmNvbG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNpcmNsZS10ZXh0XCIsXG4gICAgICAgICAgICAgICAgICBzdHlsZTogeyBcIi0tbGFiZWwtY29sb3JcIjogZiB9LFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgaC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJCXCJcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSkgfSksXG4gICAgICAgIGMgJiYgLyogQF9fUFVSRV9fICovIG4uanN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJncmFwaC1zdW1tYXJ5XCIsIHN0eWxlOiB7IFwiLS1mb3JlZ3JvdW5kLWNvbG9yXCI6IGogfSwgY2hpbGRyZW46IGMgfSlcbiAgICAgIF1cbiAgICB9XG4gICkgfSk7XG59LCBsbiA9ICh7XG4gIHRpdGxlOiBzLFxuICBiYWNrZ3JvdW5kOiBjLFxuICBmb3JlZ3JvdW5kOiBpLFxuICBsYWJlbENvbG9yOiBmLFxuICBzdW1tYXJ5OiBSLFxuICBpdGVtczogaiA9IFtdLFxuICB5ZWFyOiBiLFxuICB2YWx1ZVR5cGU6IHggPSBcIlwiLFxuICBjb2xvclNlcmllczogaCA9IFtdXG4gIC8vIE5ldyBwcm9wIGZvciBjb2xvciBzZXJpZXMgb3ZlcnJpZGVcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJob3Jpem9udGFsLWJhclwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG4uanN4cyhcbiAgXCJvbFwiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBcImxpc3QtY29udGFpbmVyXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIFwiLS1iYWNrZ3JvdW5kLWNvbG9yXCI6IGMgfHwgXCIjMGMyNjNlZmZcIlxuICAgIH0sXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIHMgJiYgLyogQF9fUFVSRV9fICovIG4uanN4KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwidGl0bGVcIiwgc3R5bGU6IHsgXCItLWZvcmVncm91bmQtY29sb3JcIjogaSB8fCBcIiMwMDBcIiB9LCBjaGlsZHJlbjogcyB9KSxcbiAgICAgIFIgJiYgLyogQF9fUFVSRV9fICovIG4uanN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdW1tYXJ5XCIsIHN0eWxlOiB7IFwiLS1mb3JlZ3JvdW5kLWNvbG9yXCI6IGkgfHwgXCIjMDAwXCIgfSwgY2hpbGRyZW46IFIgfSksXG4gICAgICBiICYmIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJoM1wiLCB7IGNsYXNzTmFtZTogXCJ5ZWFyLXRleHRcIiwgc3R5bGU6IHsgXCItLWZvcmVncm91bmQtY29sb3JcIjogaSB8fCBcIiNmZmZcIiB9LCBjaGlsZHJlbjogW1xuICAgICAgICBcIlllYXI6IFwiLFxuICAgICAgICBiXG4gICAgICBdIH0pLFxuICAgICAgai5sZW5ndGggPiAwID8gai5tYXAoKHksIG0pID0+IHtcbiAgICAgICAgY29uc3QgRSA9IGhbbV0gfHwgeS5jb2xvciB8fCBcIiNjY2NcIjtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJsaVwiLCB7IGNsYXNzTmFtZTogXCJsaXN0LWl0ZW1cIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcIm5hbWUtdGV4dFwiLCBzdHlsZTogeyBcIi0tZm9yZWdyb3VuZC1jb2xvclwiOiBpIHx8IFwiI2ZmZlwiIH0sIGNoaWxkcmVuOiB5Lm5hbWUgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxpbmUtY29udGFpbmVyXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibGluZVwiLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIFwiLS1saW5lLWNvbG9yXCI6IEUsXG4gICAgICAgICAgICAgICAgXCItLWxpbmUtd2lkdGhcIjogYCR7eS52YWx1ZX0lYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG4uanN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwidG90YWwtdmFsdWVcIiwgc3R5bGU6IHsgXCItLWxhYmVsLWNvbG9yXCI6IGYgfHwgXCIjZmZmXCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICB5LnZhbHVlLFxuICAgICAgICAgICAgICAgIHhcbiAgICAgICAgICAgICAgXSB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkgfSlcbiAgICAgICAgXSB9LCBtKTtcbiAgICAgIH0pIDogLyogQF9fUFVSRV9fICovIG4uanN4KFwicFwiLCB7IGNoaWxkcmVuOiBcIk5vIGRhdGEgYXZhaWxhYmxlXCIgfSlcbiAgICBdXG4gIH1cbikgfSksIGNuID0gKHtcbiAgdGl0bGU6IHMsXG4gIGJhY2tncm91bmQ6IGMsXG4gIGZvcmVncm91bmQ6IGksXG4gIHN1bW1hcnk6IGYsXG4gIGl0ZW1zOiBSID0gW10sXG4gIGxhYmVsQ29sb3I6IGosXG4gIHZhbHVlVHlwZTogYiA9IFwiXCIsXG4gIHZhbHVlQ29sb3I6IHgsXG4gIGNvbG9yczogaFxufSkgPT4ge1xuICBjb25zdCB5ID0gW1wiI2ZmNjM0N1wiLCBcIiM0NjgyYjRcIiwgXCIjMzJjZDMyXCIsIFwiI2RkYTBkZFwiXTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJob3Jpem9udGFsLWxpc3RcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXG4gICAgXCJvbFwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJsaXN0LWNvbnRhaW5lclwiLFxuICAgICAgc3R5bGU6IHsgXCItLWJhY2tncm91bmQtY29sb3JcIjogYyB8fCBcIiMwYzI2M2VmZlwiIH0sXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICBzICYmIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICBcImgyXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRpdGxlXCIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBcIi0tZm9yZWdyb3VuZC1jb2xvclwiOiBpIHx8IFwiIzAwMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IHNcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIGYgJiYgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgIFwicFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzdW1tYXJ5XCIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBcIi0tZm9yZWdyb3VuZC1jb2xvclwiOiBpIHx8IFwiIzAwMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IGZcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIFIubWFwKChtLCBFKSA9PiB7XG4gICAgICAgICAgY29uc3QgTiA9IG0uY29sb3IgfHwgeVtFICUgeS5sZW5ndGhdLCBMID0gbS52YWx1ZUNvbG9yIHx8IHggfHwgXCIjZmZmXCI7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJsaVwiLCB7IGNsYXNzTmFtZTogXCJsaXN0LWl0ZW1cIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgICAgXCJwXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibmFtZS10ZXh0XCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIFwiLS1sYWJlbC1jb2xvclwiOiBqIHx8IFwiIzAwMFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogbS5uYW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxpbmUtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsaW5lXCIsXG4gICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBcIi0tbGluZS1jb2xvclwiOiBOLFxuICAgICAgICAgICAgICAgICAgICBcIi0tbGluZS13aWR0aFwiOiBgJHttLnZhbHVlfSVgXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNpcmNsZVwiLFxuICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgXCItLWNpcmNsZS1jb2xvclwiOiBOLFxuICAgICAgICAgICAgICAgICAgICBcIi0tdmFsdWUtY29sb3JcIjogTFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIG0udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGJcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0gfSlcbiAgICAgICAgICBdIH0sIEUpO1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIH1cbiAgKSB9KTtcbn0sIEJyID0gKHMsIGMsIGkpID0+IGkgLSBzIC8gYyAqIGksIGp0ID0gKHMsIGMsIGkpID0+IHMgLyAoYyAtIDEpICogaSwgUXQgPSAocywgYywgaSwgZiA9IDUsIFIgPSBcIiMwMDBcIikgPT4ge1xuICBjb25zdCBqID0gW107XG4gIGZvciAobGV0IGIgPSAwOyBiIDw9IGY7IGIrKykge1xuICAgIGNvbnN0IHggPSBpIC8gZiAqIGIsIGggPSBCcih4LCBpLCBjKTtcbiAgICBqLnB1c2goXG4gICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgeDE6IFwiMFwiLFxuICAgICAgICAgIHkxOiBoLFxuICAgICAgICAgIHgyOiBzLFxuICAgICAgICAgIHkyOiBoLFxuICAgICAgICAgIHN0cm9rZTogUixcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgYGdyaWQtbGluZS0ke2J9YFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGo7XG59LCB1biA9ICh7XG4gIGRhdGE6IHMsXG4gIGNvbG9yczogYyA9IFtcbiAgICBcInJnYmEoMCwgMTIzLCAyNTUsIDAuNSlcIixcbiAgICBcInJnYmEoMCwgMjU1LCAxMjMsIDAuNSlcIixcbiAgICBcInJnYmEoMjU1LCAxMjMsIDAsIDAuNSlcIlxuICBdLFxuICBoZWlnaHQ6IGkgPSA0MDAsXG4gIHdpZHRoOiBmLFxuICBzZXJpZXNOYW1lczogUiA9IFtcIlNlcmllcyAxXCIsIFwiU2VyaWVzIDJcIiwgXCJTZXJpZXMgM1wiXSxcbiAgYmFja2dyb3VuZDogaiA9IFwiI2ZmZlwiLFxuICBsYWJlbENvbG9yOiBiID0gXCIjMDAwXCIsXG4gIGF4aXNDb2xvcjogeCA9IFwiIzAwMFwiXG59KSA9PiB7XG4gIGlmICghcyB8fCBzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4KFwicFwiLCB7IGNoaWxkcmVuOiBcIk5vIGRhdGEgYXZhaWxhYmxlXCIgfSk7XG4gIGNvbnN0IGggPSBNYXRoLm1heChcbiAgICAuLi5zLm1hcCgoUykgPT4gUy5zZXJpZXMxICsgUy5zZXJpZXMyICsgUy5zZXJpZXMzKVxuICApLCB5ID0gKFMsIFAgPSBbXSkgPT4ge1xuICAgIGxldCBPID0gXCJcIjtcbiAgICBjb25zdCBnID0gWy4uLlBdO1xuICAgIHJldHVybiBzLmZvckVhY2goKFgsIEspID0+IHtcbiAgICAgIGNvbnN0IEogPSBqdChLLCBzLmxlbmd0aCwgZiksIG5lID0gWFtTXSArIChQW0tdIHx8IDApLCBmZSA9IEJyKG5lLCBoLCBpKTtcbiAgICAgIE8gKz0gYCR7SyA9PT0gMCA/IFwiTVwiIDogXCJMXCJ9ICR7Sn0gJHtmZX0gYCwgZ1tLXSA9IG5lO1xuICAgIH0pLCBPICs9IGBMICR7Zn0gJHtpfSBMIDAgJHtpfSBaYCwgeyBwYXRoOiBPLCBhY2N1bXVsYXRlZFZhbHVlczogZyB9O1xuICB9LCBtID0geShcInNlcmllczFcIiksIEUgPSB5KFwic2VyaWVzMlwiLCBtLmFjY3VtdWxhdGVkVmFsdWVzKSwgTiA9IHkoXCJzZXJpZXMzXCIsIEUuYWNjdW11bGF0ZWRWYWx1ZXMpLCBMID0gcy5tYXAoKFMsIFApID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICBcInRleHRcIixcbiAgICB7XG4gICAgICB4OiBqdChQLCBzLmxlbmd0aCwgZiksXG4gICAgICB5OiBpICsgMjAsXG4gICAgICB0ZXh0QW5jaG9yOiBcIm1pZGRsZVwiLFxuICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgZmlsbDogeCxcbiAgICAgIGNoaWxkcmVuOiBTLm1vbnRoXG4gICAgfSxcbiAgICBTLm1vbnRoXG4gICkpLCBCID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNiB9LCAoUywgUCkgPT4ge1xuICAgIGNvbnN0IE8gPSBoIC8gNSAqIFAsIGcgPSBCcihPLCBoLCBpKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgXCJ0ZXh0XCIsXG4gICAgICB7XG4gICAgICAgIHg6IFwiLTEwXCIsXG4gICAgICAgIHk6IGcgKyA1LFxuICAgICAgICB0ZXh0QW5jaG9yOiBcImVuZFwiLFxuICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICAgIGZpbGw6IHgsXG4gICAgICAgIGNoaWxkcmVuOiBPLnRvRml4ZWQoMClcbiAgICAgIH0sXG4gICAgICBgeS1sYWJlbC0ke1B9YFxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdGFja2VkLWFyZWEtY2hhcnRcIiwgc3R5bGU6IHsgYmFja2dyb3VuZENvbG9yOiBqIH0sIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN2Zy1jb250YWluZXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICB2aWV3Qm94OiBgMCAwICR7Zn0gJHtpICsgMzB9YCxcbiAgICAgICAgc3R5bGU6IHsgb3ZlcmZsb3c6IFwidmlzaWJsZVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICBRdChmLCBpLCBoKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJwYXRoXCIsIHsgZDogTi5wYXRoLCBmaWxsOiBjWzJdLCBzdHJva2U6IFwibm9uZVwiIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcInBhdGhcIiwgeyBkOiBFLnBhdGgsIGZpbGw6IGNbMV0sIHN0cm9rZTogXCJub25lXCIgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwicGF0aFwiLCB7IGQ6IG0ucGF0aCwgZmlsbDogY1swXSwgc3Ryb2tlOiBcIm5vbmVcIiB9KSxcbiAgICAgICAgICBMLFxuICAgICAgICAgIEIsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHgxOiBcIjBcIixcbiAgICAgICAgICAgICAgeTE6IGksXG4gICAgICAgICAgICAgIHgyOiBmLFxuICAgICAgICAgICAgICB5MjogaSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiB4LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4MTogXCIwXCIsXG4gICAgICAgICAgICAgIHkxOiBcIjBcIixcbiAgICAgICAgICAgICAgeDI6IFwiMFwiLFxuICAgICAgICAgICAgICB5MjogaSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiB4LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICApIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsZWdlbmQtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBSLm1hcCgoUywgUCkgPT4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsZWdlbmQtaXRlbVwiLCBzdHlsZTogeyBjb2xvcjogYiB9LCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNvbG9yLWJveFwiLCBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IGNbUF0gfSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcInNwYW5cIiwgeyBjaGlsZHJlbjogUyB9KVxuICAgIF0gfSwgUCkpIH0pXG4gIF0gfSk7XG59LCBFdCA9IChzKSA9PiB7XG4gIGxldCBjID0gYE0gJHtzWzBdLnh9ICR7c1swXS55fWA7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBmID0gKHNbaV0ueCArIHNbaSArIDFdLngpIC8gMiwgUiA9IChzW2ldLnkgKyBzW2kgKyAxXS55KSAvIDIsIGogPSAoZiArIHNbaV0ueCkgLyAyLCBiID0gKGYgKyBzW2kgKyAxXS54KSAvIDI7XG4gICAgYyArPSBgIFEgJHtqfSAke3NbaV0ueX0sICR7Zn0gJHtSfSBRICR7Yn0gJHtzW2kgKyAxXS55fSwgJHtzW2kgKyAxXS54fSAke3NbaSArIDFdLnl9YDtcbiAgfVxuICByZXR1cm4gYztcbn0sIFp0ID0gKHMsIGMpID0+IHtcbiAgbGV0IGkgPSBFdChzKTtcbiAgY29uc3QgZiA9IHNbcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGkgKz0gYCBMICR7Zi54fSAke2N9IEwgJHtzWzBdLnh9ICR7Y30gWmAsIGk7XG59LCBmbiA9ICh7XG4gIGRhdGE6IHMsXG4gIGxhYmVsczogYyxcbiAgd2lkdGg6IGkgPSA4MDAsXG4gIGhlaWdodDogZiA9IDQwMCxcbiAgZmlsbENvbG9yOiBSLFxuICBzdHJva2VDb2xvcjogaixcbiAgYmFja2dyb3VuZDogYixcbiAgbGFiZWxDb2xvcjogeCxcbiAgbGluZUNvbG9yOiBoXG59KSA9PiB7XG4gIGNvbnN0IHkgPSBNYXRoLm1heCguLi5zKSwgbSA9IGkgLyAocy5sZW5ndGggLSAxKSwgRSA9IDIwLCBOID0gcy5tYXAoKEwsIEIpID0+ICh7XG4gICAgeDogRSArIEIgKiBtLFxuICAgIHk6IGYgLSBMIC8geSAqIGZcbiAgfSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcInNwbGluZS1jaGFydC1jb250YWluZXJcIixcbiAgICAgIHN0eWxlOiB7IFwiLS1jaGFydC1oZWlnaHRcIjogYCR7Zn1weGAsIFwiLS1jaGFydC1iYWNrZ3JvdW5kXCI6IGIgfHwgXCIjZjlmOWY5XCIgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBcInN2Zy1jb250YWluZXJcIiwgdmlld0JveDogYDAgMCAke2l9ICR7Zn1gLCBjaGlsZHJlbjogW1xuICAgICAgICBOLm1hcCgoTCwgQikgPT4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImdcIiwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4MTogTC54LFxuICAgICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgICAgeDI6IEwueCxcbiAgICAgICAgICAgICAgeTI6IGYsXG4gICAgICAgICAgICAgIHN0eWxlOiB7IHN0cm9rZTogaCB8fCBcIiNjY2NcIiB9LFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwidmVydGljYWwtbGluZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJ0ZXh0XCIsIHsgeDogTC54LCB5OiBmIC0gNSwgdGV4dEFuY2hvcjogXCJtaWRkbGVcIiwgc3R5bGU6IHsgZmlsbDogeCB8fCBcIiMzMzNcIiB9LCBjbGFzc05hbWU6IFwiYXhpcy1sYWJlbFwiLCBjaGlsZHJlbjogY1tCXSB9KVxuICAgICAgICBdIH0sIEIpKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgIFwicGF0aFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGQ6IFp0KE4sIGYpLFxuICAgICAgICAgICAgc3R5bGU6IHsgZmlsbDogUiB8fCBcIiM0NjgyYjRcIiB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImFyZWEtcGF0aFwiXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgICAgXCJwYXRoXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZDogRXQoTiksXG4gICAgICAgICAgICBzdHlsZTogeyBzdHJva2U6IGogfHwgXCIjNDY4MmI0XCIgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcGxpbmUtcGF0aFwiXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdIH0pXG4gICAgfVxuICApO1xufTtcbnZhciBlbiA9IEhyKCk7XG5jb25zdCBrdCA9IC8qIEBfX1BVUkVfXyAqLyBxdChlbiksIGRuID0gKHtcbiAgcmlza0RhdGE6IHMsXG4gIGxpa2VsaWhvb2RMYWJlbHM6IGMsXG4gIGltcGFjdExhYmVsczogaSxcbiAgYmFja2dyb3VuZDogZiA9IFwiI2ZmZlwiLFxuICBmb3JlZ3JvdW5kOiBSID0gXCIjMDAwXCIsXG4gIGxhYmVsQ29sb3I6IGosXG4gIGNvbG9yczogYlxufSkgPT4ge1xuICBjb25zdCB4ID0gKHkpID0+IHtcbiAgICBzd2l0Y2ggKHkpIHtcbiAgICAgIGNhc2UgXCJsb3dcIjpcbiAgICAgICAgcmV0dXJuIGJbMF07XG4gICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgIHJldHVybiBiWzFdO1xuICAgICAgY2FzZSBcImhpZ2hcIjpcbiAgICAgICAgcmV0dXJuIGJbMl07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCIjZmZmXCI7XG4gICAgfVxuICB9LCBoID0gKHkpID0+IHtcbiAgICBzd2l0Y2ggKHkpIHtcbiAgICAgIGNhc2UgXCJsb3dcIjpcbiAgICAgICAgcmV0dXJuIGpbMF07XG4gICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgIHJldHVybiBqWzFdO1xuICAgICAgY2FzZSBcImhpZ2hcIjpcbiAgICAgICAgcmV0dXJuIGpbMl07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCIjMzMzXCI7XG4gICAgfVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwidGl0bGVcIiwgc3R5bGU6IHsgY29sb3I6IFIgfSwgY2hpbGRyZW46IFwiUmlzayBSYXRpbmcgTWF0cml4XCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJtYXRyaXgtY29udGFpbmVyXCIsIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogZiB9LCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImF4aXMtbGFiZWxcIiB9KSxcbiAgICAgIGMubWFwKCh5LCBtKSA9PiAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYXhpcy1sYWJlbFwiLCBzdHlsZTogeyBjb2xvcjogUiB9LCBjaGlsZHJlbjogeSB9LCBtKSksXG4gICAgICBzLm1hcCgoeSwgbSkgPT4gLyogQF9fUFVSRV9fICovIG4uanN4cyhrdC5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYXhpcy1sYWJlbFwiLCBzdHlsZTogeyBjb2xvcjogUiB9LCBjaGlsZHJlbjogaVttXSB9KSxcbiAgICAgICAgeS5tYXAoKEUsIE4pID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJtYXRyaXgtY2VsbFwiLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB4KEUpLFxuICAgICAgICAgICAgICBjb2xvcjogaChFKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBFLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgRS5zbGljZSgxKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYCR7bX0tJHtOfWBcbiAgICAgICAgKSlcbiAgICAgIF0gfSwgbSkpXG4gICAgXSB9KVxuICBdIH0pO1xufSwgcm4gPSAocykgPT4ge1xuICBjb25zdCBjID0gTWF0aC5taW4oMjU1LCBNYXRoLmZsb29yKDI1NSAqIHMgLyAxMDApKSwgaSA9IE1hdGgubWluKDI1NSwgTWF0aC5mbG9vcigyNTUgKiAoMTAwIC0gcykgLyAxMDApKTtcbiAgcmV0dXJuIGByZ2IoJHtjfSwgMCwgJHtpfSlgO1xufSwgcG4gPSAoe1xuICBkYXRhOiBzLFxuICBtb250aHM6IGMsXG4gIHJvd0xhYmVsczogaSxcbiAgYmFja2dyb3VuZDogZixcbiAgbGFiZWxDb2xvcjogUixcbiAgdmFsdWVDb2xvcjogalxufSkgPT4ge1xuICBjb25zdCBiID0gaS5sZW5ndGgsIHggPSBjLmxlbmd0aDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiaGVhdG1hcC13cmFwcGVyXCIsIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogZiwgXCItLW51bS1jb2x1bW5zXCI6IHgsIFwiLS1udW0tcm93c1wiOiBiIH0sIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHt9KSxcbiAgICBjLm1hcCgoaCwgeSkgPT4gLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImRhdGUtbGFiZWxcIiwgc3R5bGU6IHsgY29sb3I6IFIgfSwgY2hpbGRyZW46IGggfSwgeSkpLFxuICAgIHMubWFwKChoLCB5KSA9PiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKGt0LkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicm93LWxhYmVsXCIsIHN0eWxlOiB7IGNvbG9yOiBSIH0sIGNoaWxkcmVuOiBpW3ldIH0pLFxuICAgICAgaC5tYXAoKG0sIEUpID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJoZWF0bWFwLWNlbGxcIixcbiAgICAgICAgICBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHJuKG0pLCBjb2xvcjogaiB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBtXG4gICAgICAgIH0sXG4gICAgICAgIEVcbiAgICAgICkpXG4gICAgXSB9LCB5KSlcbiAgXSB9KTtcbn0sIHZuID0gKHtcbiAgZGF0YTogcyxcbiAgbGVnZW5kOiBjLFxuICBiYWNrZ3JvdW5kOiBpLFxuICB0ZXh0Q29sb3I6IGYsXG4gIGRlZmF1bHRDb2xvcnM6IFIsXG4gIGV4cGxhbmF0aW9uOiBqLFxuICBiYXJXaWR0aDogYiA9IFwiOTAlXCJcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdGFja2VkLXJvdy1jaGFydFwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaGFydC1jb250YWluZXJcIiwgc3R5bGU6IHsgYmFja2dyb3VuZENvbG9yOiBpIH0sIGNoaWxkcmVuOiBbXG4gIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibGVnZW5kLWV4cGxhbmF0aW9uLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJleHBsYW5hdGlvbi10ZXh0XCIsIHN0eWxlOiB7IGNvbG9yOiBmIH0sIGNoaWxkcmVuOiBqIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsZWdlbmQtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBjLm1hcCgoeCwgaCkgPT4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsZWdlbmQtaXRlbVwiLCBzdHlsZTogeyBjb2xvcjogZiB9LCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNvbG9yLWJveFwiLCBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHguY29sb3IgfSB9KSxcbiAgICAgIHgubGFiZWxcbiAgICBdIH0sIGgpKSB9KVxuICBdIH0pLFxuICBzLm1hcCgoeCwgaCkgPT4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyb3dcIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZGVzY3JpcHRpb25cIiwgc3R5bGU6IHsgY29sb3I6IGYgfSwgY2hpbGRyZW46IHguZGVzY3JpcHRpb24gfSksXG4gICAgLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJiYXItY29udGFpbmVyXCIsIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogaSwgd2lkdGg6IGIgfSwgY2hpbGRyZW46IFtcbiAgICAgIHguc2VnbWVudHMubWFwKCh5LCBtKSA9PiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImJhci1zZWdtZW50XCIsXG4gICAgICAgICAgc3R5bGU6IHsgZmxleDogeS52YWx1ZSwgYmFja2dyb3VuZENvbG9yOiB5LmNvbG9yIHx8IFJbbV0sIGNvbG9yOiB5LnRleHRDb2xvciB8fCBcIiNmZmZcIiB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB5LnZhbHVlLFxuICAgICAgICAgICAgXCIlXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIG1cbiAgICAgICkpLFxuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImJhci12YWx1ZVwiLCBzdHlsZTogeyBjb2xvcjogZiB9IH0pXG4gICAgXSB9KVxuICBdIH0sIGgpKVxuXSB9KSB9KSwgenIgPSAocywgYywgaSkgPT4gcyA9PSBudWxsID8gMCA6IGkgLSBzIC8gYyAqIGksIFJ0ID0gKHMsIGMsIGkpID0+IHMgLyBjICogaSwgdG4gPSAocyA9IFwiIzAwMFwiLCBjLCBpLCBmLCBSID0gNSkgPT4ge1xuICBjb25zdCBqID0gW107XG4gIGZvciAobGV0IGIgPSAwOyBiIDw9IFI7IGIrKykge1xuICAgIGNvbnN0IHggPSBmIC8gUiAqIGIsIGggPSB6cih4LCBmLCBpKTtcbiAgICBqLnB1c2goXG4gICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgeDE6IFwiMFwiLFxuICAgICAgICAgIHkxOiBoLFxuICAgICAgICAgIHgyOiBjLFxuICAgICAgICAgIHkyOiBoLFxuICAgICAgICAgIHN0cm9rZTogcyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgYGdyaWQtbGluZS0ke2J9YFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGo7XG59LCBobiA9ICh7XG4gIGRhdGE6IHMsXG4gIGNvbG9yczogYyA9IFtcInJnYmEoMCwgMTIzLCAyNTUsIDAuNylcIiwgXCJyZ2JhKDAsIDI1NSwgMTIzLCAwLjcpXCIsIFwicmdiYSgyNTUsIDEyMywgMCwgMC43KVwiXSxcbiAgaGVpZ2h0OiBpID0gNDAwLFxuICB3aWR0aDogZixcbiAgLy8gV2lkdGggaXMgbm93IHJlcXVpcmVkIGFuZCBwYXNzZWQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudFxuICBzZXJpZXNOYW1lczogUiA9IFtcIlNlcmllcyAxXCIsIFwiU2VyaWVzIDJcIiwgXCJTZXJpZXMgM1wiXSxcbiAgYmFja2dyb3VuZDogaixcbiAgZm9yZWdyb3VuZDogYixcbiAgbGFiZWxDb2xvcjogeCxcbiAgdmFsdWVDb2xvcjogaCxcbiAgYXhpc0NvbG9yOiB5XG59KSA9PiB7XG4gIGlmICghcyB8fCBzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4KFwicFwiLCB7IGNoaWxkcmVuOiBcIk5vIGRhdGEgYXZhaWxhYmxlXCIgfSk7XG4gIGNvbnN0IG0gPSBNYXRoLm1heChcbiAgICAuLi5zLm1hcChcbiAgICAgIChPKSA9PiBPYmplY3QudmFsdWVzKE8pLmZpbHRlcigoZykgPT4gdHlwZW9mIGcgPT0gXCJudW1iZXJcIikucmVkdWNlKChnLCBYKSA9PiBnICsgWCwgMClcbiAgICApXG4gICksIEUgPSBmIC8gcy5sZW5ndGggLyAyLCBOID0gZiAvIHMubGVuZ3RoLCBMID0gKE8sIGcpID0+IHtcbiAgICBsZXQgWCA9IDA7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKE8pLm1hcCgoSywgSikgPT4ge1xuICAgICAgaWYgKEsgPT09IFwibW9udGhcIikgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBuZSA9IE9bS10sIGZlID0gUnQoZywgcy5sZW5ndGgsIGYpICsgTiAvIDQsIHZlID0gaSAtIHpyKG5lLCBtLCBpKSwgZ2UgPSBpIC0gdmUgLSBYO1xuICAgICAgcmV0dXJuIFggKz0gdmUsIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgXCJyZWN0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICB4OiBmZSxcbiAgICAgICAgICB5OiBnZSxcbiAgICAgICAgICB3aWR0aDogRSxcbiAgICAgICAgICBoZWlnaHQ6IHZlLFxuICAgICAgICAgIGZpbGw6IGNbSiAtIDFdXG4gICAgICAgIH0sXG4gICAgICAgIGAke0t9LSR7Z31gXG4gICAgICApO1xuICAgIH0pO1xuICB9LCBCID0gcy5tYXAoKE8sIGcpID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICBcInRleHRcIixcbiAgICB7XG4gICAgICB4OiBSdChnLCBzLmxlbmd0aCwgZikgKyBOIC8gMixcbiAgICAgIHk6IGkgKyAyMCxcbiAgICAgIHRleHRBbmNob3I6IFwibWlkZGxlXCIsXG4gICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICBmaWxsOiB5LFxuICAgICAgY2hpbGRyZW46IE8ubW9udGhcbiAgICB9LFxuICAgIGdcbiAgKSksIFMgPSA1LCBQID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogUyArIDEgfSwgKE8sIGcpID0+IHtcbiAgICBjb25zdCBYID0gbSAvIFMgKiBnLCBLID0genIoWCwgbSwgaSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgIFwidGV4dFwiLFxuICAgICAge1xuICAgICAgICB4OiBcIi0xMFwiLFxuICAgICAgICB5OiBLICsgNSxcbiAgICAgICAgdGV4dEFuY2hvcjogXCJlbmRcIixcbiAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICBmaWxsOiB5LFxuICAgICAgICBjaGlsZHJlbjogWC50b0ZpeGVkKDApXG4gICAgICB9LFxuICAgICAgYHktbGFiZWwtJHtnfWBcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RhY2tlZC1iYXItY2hhcnRcIiwgc3R5bGU6IHsgYmFja2dyb3VuZENvbG9yOiBqIH0sIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN2Zy1jb250YWluZXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICB2aWV3Qm94OiBgMCAwICR7Zn0gJHtpICsgMzB9YCxcbiAgICAgICAgc3R5bGU6IHsgb3ZlcmZsb3c6IFwidmlzaWJsZVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB0bih5IHx8IFwiIzAwMFwiLCBmLCBpLCBtLCBTKSxcbiAgICAgICAgICBzLm1hcCgoTywgZykgPT4gLyogQF9fUFVSRV9fICovIG4uanN4KFwiZ1wiLCB7IGNoaWxkcmVuOiBMKE8sIGcpIH0sIGBiYXItZ3JvdXAtJHtnfWApKSxcbiAgICAgICAgICBCLFxuICAgICAgICAgIFAsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHgxOiBcIjBcIixcbiAgICAgICAgICAgICAgeTE6IGksXG4gICAgICAgICAgICAgIHgyOiBmLFxuICAgICAgICAgICAgICB5MjogaSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiB5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4MTogXCIwXCIsXG4gICAgICAgICAgICAgIHkxOiBcIjBcIixcbiAgICAgICAgICAgICAgeDI6IFwiMFwiLFxuICAgICAgICAgICAgICB5MjogaSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiB5IHx8IFwiIzAwMFwiLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICApIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsZWdlbmQtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBSLm1hcCgoTywgZykgPT4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsZWdlbmQtaXRlbVwiLCBzdHlsZTogeyBjb2xvcjogeCB9LCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNvbG9yLWJveFwiLCBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IGNbZ10gfSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcInNwYW5cIiwgeyBjaGlsZHJlbjogTyB9KVxuICAgIF0gfSwgZykpIH0pXG4gIF0gfSk7XG59LCB5biA9ICh7XG4gIGRhdGE6IHMsXG4gIHRpdGxlOiBjLFxuICBiYWNrZ3JvdW5kOiBpID0gXCJcIixcbiAgZm9yZWdyb3VuZDogZiA9IFwiXCIsXG4gIGJhckNvbG9yOiBSID0gXCJcIixcbiAgdGFyZ2V0Q29sb3I6IGogPSBcIlwiXG59KSA9PiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFxuICBcImRpdlwiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBcImJlbmNobWFyay1jb250YWluZXJcIixcbiAgICBzdHlsZToge1xuICAgICAgXCItLWJhY2tncm91bmQtY29sb3JcIjogaSxcbiAgICAgIFwiLS1mb3JlZ3JvdW5kLWNvbG9yXCI6IGZcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICBjICYmIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImgyXCIsIHsgY2xhc3NOYW1lOiBcImNoYXJ0LXRpdGxlXCIsIGNoaWxkcmVuOiBjIH0pLFxuICAgICAgcy5tYXAoKGIsIHgpID0+IC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYmFyLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYmFyLWxhYmVsXCIsIGNoaWxkcmVuOiBiLmxhYmVsIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFwiZGl2XCIsIHsgc3R5bGU6IHsgZmxleEJhc2lzOiBcIjcwJVwiLCBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJlbmNobWFyay1saW5lXCIsXG4gICAgICAgICAgICAgIFwiZGF0YS1sYWJlbFwiOiBgVGFyZ2V0OiAke2IuYmVuY2htYXJrfSVgLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIFwiLS1iZW5jaG1hcmstY29sb3JcIjogaixcbiAgICAgICAgICAgICAgICBcIi0tYmVuY2htYXJrLXBlcmNlbnRhZ2VcIjogYCR7Yi5iZW5jaG1hcmt9JWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJhclwiLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBgJHtiLmFjdHVhbH0lYCxcbiAgICAgICAgICAgICAgICBcIi0tYmFyLWNvbG9yXCI6IFJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IHN0eWxlOiB7IGZsZXhCYXNpczogXCIxMCVcIiwgdGV4dEFsaWduOiBcInJpZ2h0XCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICBiLmFjdHVhbCxcbiAgICAgICAgICBcIiVcIlxuICAgICAgICBdIH0pXG4gICAgICBdIH0sIHgpKVxuICAgIF1cbiAgfVxuKSwgbW4gPSAoe1xuICB0aXRsZTogcyxcbiAgcGVyY2VudGFnZTogYyxcbiAgYmFja2dyb3VuZDogaSA9IFwiI2ZmZlwiLFxuICBmb3JlZ3JvdW5kOiBmID0gXCIjMDAwXCIsXG4gIGRlc2NyaXB0aW9uOiBSID0gXCJcIixcbiAgYWN0aXZlQ29sb3I6IGogPSBcIiM0Y2FmNTBcIixcbiAgbm9uQWN0aXZlQ29sb3I6IGIgPSBcIiNjY2NcIixcbiAgc2l6ZTogeCA9IDEwMFxufSkgPT4ge1xuICBjb25zdCB5ID0gTWF0aC5mbG9vcihjIC8gMTAwICogMTAwKSwgbSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoRSwgTikgPT4gLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgIFwic3ZnXCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcIm1hbi1pY29uXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiBOID49IDEwMCAtIHkgPyBqIDogYlxuICAgICAgfSxcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAxMDAgMjEwXCIsXG4gICAgICB3aWR0aDogeCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJwYXRoXCIsIHsgZDogXCJNNTAuMjggOC40NGExOS41MDYgMTkuOTcgMCAwIDAtMTkuNTA3IDE5Ljk3IDE5LjUwNiAxOS45NyAwIDAgMCAxMS45NyAxOC40MDZjLTEwLjYzLjgwNi0xOS43NDMgMy4zMjctMjEuMDMgNy4zMzJMMy41OTYgMTE2LjY4Yy0xLjM3NiA0Ljc0NCAxLjE0NiA5LjU5NyA1LjY1NSAxMC44OGwxLjkwMy41NDVjNC41MDggMS4yODMgOS4yNDgtMS41MDkgMTAuNjIyLTYuMjUybDkuMTk0LTQwLjY3Yy0yLjY1NCAzMy4zMjItMi40MSA3Ny4yNDItMy42ODIgMTEyLjcyNC0uMTc5IDQuOTM1IDMuNDU5IDkuMDE4IDguMTQ0IDkuMTYzbDEuOTc1LjA2NmM0LjY4NS4xNTkgOC42MDUtMy43MTMgOC43ODItOC42NDhsMS45NDMtNjcuNDc5aDMuNDk3bDEuOTQzIDY3LjQ3OWMuMTc5IDQuOTM1IDQuMDg2IDguNzkyIDguNzcyIDguNjQ4bDEuOTg0LS4wNjZjNC42ODYtLjE2IDguMzExLTQuMjI4IDguMTM0LTkuMTYzLTEuNjc3LTMyLjEyOC0uNzk2LTgwLjMzNS00LjQyMS0xMTAuNDFsMTEuMTQ3IDM4LjY2NGMxLjM3NSA0Ljc0MyA2LjEwMyA3LjUyNSAxMC42MTIgNi4yNDJsMS45MDItLjU0NWM0LjUxLTEuMjgzIDcuMDQtNi4xMjYgNS42NjYtMTAuODY5bC0xOC4xMy02Mi41NDNjLTIuMTE0LTQuMzYzLTExLjEyNS02LjgzNy0yMS40Mi03LjYzYTE5LjUwNiAxOS45NyAwIDAgMCAxMS45Ny0xOC40MDdBMTkuNTA2IDE5Ljk3IDAgMCAwIDUwLjI4IDguNDRaXCIgfSlcbiAgICB9LFxuICAgIE5cbiAgKSkucmV2ZXJzZSgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWZmbGUtY2hhcnQtY29udGFpbmVyXCIsIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogaSB9LCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImgyXCIsIHsgY2xhc3NOYW1lOiBcIndhZmZsZS10aXRsZVwiLCBzdHlsZTogeyBjb2xvcjogZiB9LCBjaGlsZHJlbjogcyB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcImRlc2NyaXB0aW9uXCIsIHN0eWxlOiB7IGNvbG9yOiBmIH0sIGNoaWxkcmVuOiBSIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2hhcnQtY29udGVudFwiLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwic3BhblwiLCB7IHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbFwiOiBgdGhlIHBpY3RvZ3JhcGggb2YgMTAwIHN0aWNrIHBlb3BsZSwgd2l0aCAke2N9IHNob3dpbmcgYXMgYWN0aXZlYCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWZmbGUtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBtIH0pIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJwZXJjZW50YWdlLWNvbnRhaW5lclwiLCBzdHlsZTogeyBjb2xvcjogaiB9LCBjaGlsZHJlbjogW1xuICAgICAgICBjLFxuICAgICAgICBcIiVcIlxuICAgICAgXSB9KVxuICAgIF0gfSlcbiAgXSB9KTtcbn0sIGduID0gKHtcbiAgdGl0bGU6IHMsXG4gIGRhdGE6IGMsXG4gIGZpbGxDb2xvcjogaSA9IFwiIzQ2ODJiNFwiLFxuICAvLyBEZWZhdWx0IGZpbGwgY29sb3IgZm9yIGJhcnNcbiAgYmFja2dyb3VuZENvbG9yOiBmID0gXCIjZmZmXCIsXG4gIC8vIERlZmF1bHQgYmFja2dyb3VuZCBjb2xvclxuICBmb3JlZ3JvdW5kQ29sb3I6IFIgPSBcIiMwMDBcIixcbiAgLy8gRGVmYXVsdCBmb3JlZ3JvdW5kIGNvbG9yXG4gIG5vVG90YWw6IGogPSAhMVxufSkgPT4ge1xuICBpZiAoIWMgfHwgYy5sZW5ndGggPT09IDApIHJldHVybiAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJwXCIsIHsgY2hpbGRyZW46IFwiTm8gZGF0YSBhdmFpbGFibGVcIiB9KTtcbiAgY29uc3QgYiA9IGMucmVkdWNlKChFLCB7IHZhbHVlOiBOIH0pID0+IEUgKyBOLCAwKSwgeCA9IDMwMCwgaCA9IDUwLCB5ID0gTWF0aC5tYXgoLi4uYy5tYXAoKEUpID0+IEUudmFsdWUpKSwgbSA9IHggLyBjLmxlbmd0aDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwic3BhcmtiYXItY2hhcnQtY29udGFpbmVyXCIsXG4gICAgICBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IGYsIGNvbG9yOiBSIH0sXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAhaiAmJiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKG4uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3BhcmtiYXItdGl0bGVcIiwgY2hpbGRyZW46IHMgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzcGFya2Jhci10b3RhbFwiLCBjaGlsZHJlbjogYiB9KVxuICAgICAgICBdIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwic3BhcmtiYXItc3ZnXCIsIHdpZHRoOiB4LCBoZWlnaHQ6IGgsIGNoaWxkcmVuOiBjLm1hcCgoRSwgTikgPT4gLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgIFwicmVjdFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcGFya2Jhci1yZWN0XCIsXG4gICAgICAgICAgICB4OiBOICogbSxcbiAgICAgICAgICAgIHk6IGggLSBFLnZhbHVlIC8geSAqIGgsXG4gICAgICAgICAgICB3aWR0aDogbSAtIDIsXG4gICAgICAgICAgICBoZWlnaHQ6IEUudmFsdWUgLyB5ICogaCxcbiAgICAgICAgICAgIGZpbGw6IGlcbiAgICAgICAgICB9LFxuICAgICAgICAgIE5cbiAgICAgICAgKSkgfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59LCBibiA9ICh7XG4gIHRpdGxlOiBzLFxuICB0b3RhbDogYyxcbiAgdmFsdWU6IGksXG4gIGJhckNvbG9yOiBmID0gXCIjNDY4MmI0XCIsXG4gIC8vIERlZmF1bHQgZmlsbCBjb2xvciBmb3IgdGhlIGJhclxuICBiYWNrZ3JvdW5kOiBSID0gXCIjZTBlMGUwXCIsXG4gIC8vIERlZmF1bHQgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgd3JhcHBlclxuICBmb3JlZ3JvdW5kOiBqID0gXCIjMDAwXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBjb2xvciBmb3IgdGl0bGUgYW5kIHZhbHVlXG4gIHN1ZmZpeDogYiA9IFwiXCJcbiAgLy8gT3B0aW9uYWwgc3VmZml4LCBkZWZhdWx0IGlzIGFuIGVtcHR5IHN0cmluZ1xufSkgPT4ge1xuICBjb25zdCB4ID0gaSAvIGMgKiAxMDA7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLWhvcml6b250YWwtYmFyLWNvbnRhaW5lclwiLCBzdHlsZTogeyBjb2xvcjogaiB9LCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3BhcmstaG9yaXpvbnRhbC1iYXItaW5mb1wiLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG4uanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzcGFyay1ob3Jpem9udGFsLWJhci10aXRsZVwiLCBjaGlsZHJlbjogcyB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLWhvcml6b250YWwtYmFyLXZhbHVlXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgIGksXG4gICAgICAgIGJcbiAgICAgIF0gfSlcbiAgICBdIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzcGFyay1ob3Jpem9udGFsLWJhci13cmFwcGVyXCIsIHN0eWxlOiB7IGJhY2tncm91bmQ6IFIgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzcGFyay1ob3Jpem9udGFsLWJhci1maWxsXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2lkdGg6IGAke3h9JWAsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApIH0pXG4gIF0gfSk7XG59LCBubiA9IChzKSA9PiB7XG4gIGlmICghcyB8fCBzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gIGxldCBjID0gYE0gJHtzWzBdLnh9ICR7c1swXS55fWA7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBmID0gKHNbaV0ueCArIHNbaSArIDFdLngpIC8gMiwgUiA9IChzW2ldLnkgKyBzW2kgKyAxXS55KSAvIDIsIGogPSAoZiArIHNbaV0ueCkgLyAyLCBiID0gKGYgKyBzW2kgKyAxXS54KSAvIDI7XG4gICAgYyArPSBgIFEgJHtqfSAke3NbaV0ueX0sICR7Zn0gJHtSfSBRICR7Yn0gJHtzW2kgKyAxXS55fSwgJHtzW2kgKyAxXS54fSAke3NbaSArIDFdLnl9YDtcbiAgfVxuICByZXR1cm4gYztcbn0sIHhuID0gKHtcbiAgdGl0bGU6IHMsXG4gIGRhdGE6IGMsXG4gIC8vIERhdGEgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGl0ZW0gYW5kIHZhbHVlXG4gIHN0cm9rZUNvbG9yOiBpID0gXCIjNDY4MmI0XCIsXG4gIC8vIERlZmF1bHQgc3Ryb2tlIGNvbG9yXG4gIHN0cm9rZVdpZHRoOiBmID0gMixcbiAgLy8gRGVmYXVsdCBzdHJva2Ugd2lkdGhcbiAgYmFja2dyb3VuZENvbG9yOiBSID0gXCIjZmZmXCIsXG4gIC8vIERlZmF1bHQgYmFja2dyb3VuZCBjb2xvciAod2hpdGUpXG4gIGZvcmVncm91bmRDb2xvcjogaiA9IFwiIzAwMFwiXG4gIC8vIERlZmF1bHQgZm9yZWdyb3VuZCBjb2xvciAoYmxhY2spXG59KSA9PiB7XG4gIGlmICghYyB8fCBjLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcInBcIiwgeyBjaGlsZHJlbjogXCJObyBkYXRhIGF2YWlsYWJsZVwiIH0pO1xuICBjb25zdCBiID0gYy5yZWR1Y2UoKEIsIHsgdmFsdWU6IFMgfSkgPT4gQiArIFMsIDApLCB4ID0gMzAwLCBoID0gNTAsIHkgPSBNYXRoLm1heCguLi5jLm1hcCgoQikgPT4gQi52YWx1ZSkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcInBcIiwgeyBjaGlsZHJlbjogXCJObyB2YWxpZCBkYXRhXCIgfSk7XG4gIGNvbnN0IG0gPSB4IC8gTWF0aC5tYXgoMSwgYy5sZW5ndGggLSAxKSwgRSA9IGYgLyAyLCBOID0gYy5tYXAoKEIsIFMpID0+ICh7XG4gICAgeDogRSArIFMgKiBtLFxuICAgIHk6IGggLSBCLnZhbHVlIC8geSAqIGhcbiAgfSkpLCBMID0geCArIEU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcInNwYXJrbGluZS1jaGFydC1jb250YWluZXJcIixcbiAgICAgIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogUiwgY29sb3I6IGogfSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzcGFya2xpbmUtdGl0bGVcIiwgY2hpbGRyZW46IHMgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeChcInBcIiwgeyBjbGFzc05hbWU6IFwic3BhcmtsaW5lLXRvdGFsXCIsIGNoaWxkcmVuOiBiIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXG4gICAgICAgICAgXCJzdmdcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic3BhcmtsaW5lLXN2Z1wiLFxuICAgICAgICAgICAgdmlld0JveDogYDAgMCAke0x9ICR7aH1gLFxuICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgICAgICAgICBcInBhdGhcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGQ6IG5uKE4pLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcGFya2xpbmUtcGF0aFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBzdHJva2U6IGksXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn0sIF9uID0gKHtcbiAgdGl0bGU6IHMsXG4gIHRvdGFsOiBjLFxuICBzZWdtZW50czogaSxcbiAgYmFja2dyb3VuZDogZiA9IFwiI2UwZTBlMFwiLFxuICAvLyBEZWZhdWx0IGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHdyYXBwZXJcbiAgZm9yZWdyb3VuZDogUiA9IFwiIzAwMFwiLFxuICAvLyBEZWZhdWx0IHRleHQgY29sb3IgZm9yIHRpdGxlIGFuZCB2YWx1ZVxuICBzdWZmaXg6IGogPSBcIlwiLFxuICAvLyBPcHRpb25hbCBzdWZmaXgsIGRlZmF1bHQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gIGhlaWdodDogYiA9IFwiMjBweFwiXG4gIC8vIERlZmF1bHQgaGVpZ2h0IGZvciB0aGUgc3RhY2tlZCBiYXIsIGNhbiBiZSBvdmVycmlkZGVuXG59KSA9PiAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLXN0YWNrZWQtYmFyLWNvbnRhaW5lclwiLCBzdHlsZTogeyBjb2xvcjogUiwgYmFja2dyb3VuZDogZiB9LCBjaGlsZHJlbjogW1xuICAvKiBAX19QVVJFX18gKi8gbi5qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLXN0YWNrZWQtYmFyLWluZm9cIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gbi5qc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLXN0YWNrZWQtYmFyLXRpdGxlXCIsIGNoaWxkcmVuOiBzIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuLmpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLXN0YWNrZWQtYmFyLXZhbHVlXCIsIGNoaWxkcmVuOiBbXG4gICAgICBpLnJlZHVjZSgoeCwgaCkgPT4geCArIGgudmFsdWUsIDApLFxuICAgICAgalxuICAgIF0gfSlcbiAgXSB9KSxcbiAgLyogQF9fUFVSRV9fICovIG4uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwYXJrLXN0YWNrZWQtYmFyLXdyYXBwZXJcIiwgc3R5bGU6IHsgYmFja2dyb3VuZDogZiwgaGVpZ2h0OiBiIH0sIGNoaWxkcmVuOiBpLm1hcCgoeCwgaCkgPT4ge1xuICAgIGNvbnN0IHkgPSB4LnZhbHVlIC8gYyAqIDEwMDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG4uanN4KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNwYXJrLXN0YWNrZWQtYmFyLXNlZ21lbnRcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aWR0aDogYCR7eX0lYCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHguY29sb3IsXG4gICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIlxuICAgICAgICAgIC8vIEVuc3VyZXMgdGhlIHNlZ21lbnQgcmVzcGVjdHMgdGhlIHdyYXBwZXIncyBoZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhcbiAgICApO1xuICB9KSB9KVxuXSB9KTtcbmV4cG9ydCB7XG4gIHluIGFzIEJlbmNobWFya0NoYXJ0LFxuICBzbiBhcyBDb21wYXJpc29uR3JhcGgsXG4gIGFuIGFzIERvdWdobnV0Q2hhcnQsXG4gIG9uIGFzIER1bWJiZWxsQ2hhcnQsXG4gIHBuIGFzIEhlYXRNYXAsXG4gIGxuIGFzIEhvcml6b250YWxCYXIsXG4gIGNuIGFzIEhvcml6b250YWxMaXN0LFxuICBkbiBhcyBSaXNrUmF0aW5nLFxuICBnbiBhcyBTcGFya0JhcixcbiAgYm4gYXMgU3BhcmtIb3Jpem9udGFsQmFyLFxuICB4biBhcyBTcGFya0xpbmUsXG4gIF9uIGFzIFNwYXJrU3RhY2tlZEJhcixcbiAgZm4gYXMgU3BsaW5lQXJlYUNoYXJ0LFxuICB1biBhcyBTdGFja2VkQXJlYUNoYXJ0LFxuICBobiBhcyBTdGFja2VkQmFyQ2hhcnQsXG4gIHZuIGFzIFN0YWNrZWRSb3csXG4gIG1uIGFzIFdhZmZsZUNoYXJ0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/infocharts/dist/index.es.js\n");

/***/ })

};
;